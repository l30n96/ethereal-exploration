<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ethereal Exploration - Multiplayer</title>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box;
        }
        
        html, body { 
            width: 100%; 
            height: 100%; 
            overflow: hidden; 
            background: #000; 
            font-family: Arial, sans-serif; 
        }
        
        #gameCanvas { 
            display: block; 
            width: 100vw !important;
            height: 100vh !important;
            position: fixed;
            top: 0;
            left: 0;
        }
        
        .ui-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 100; color: white;
        }
        
        .hud {
            position: absolute; top: 20px; left: 20px;
            font-size: 14px; text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        
        .connection-status {
            position: absolute; top: 20px; left: 50%;
            transform: translateX(-50%); padding: 5px 10px;
            background: rgba(0,0,0,0.7); border-radius: 15px;
            font-size: 12px;
        }
        
        .connected { color: #4ecdc4; }
        .connecting { color: #ffd93d; }
        .disconnected { color: #ff6b6b; }
        
        .chat-container {
            position: absolute; bottom: 20px; left: 20px;
            width: 350px; pointer-events: all;
        }
        
        .chat-messages {
            background: rgba(0,0,0,0.8); border-radius: 10px;
            padding: 10px; max-height: 150px; overflow-y: auto;
            margin-bottom: 10px; font-size: 12px;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }
        
        .chat-input {
            width: 100%; padding: 8px; border: none; border-radius: 5px;
            background: rgba(0,0,0,0.8); color: white;
            border: 1px solid rgba(78, 205, 196, 0.5);
            font-size: 12px;
        }
        
        .chat-input:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.3);
        }
        
        .chat-input::placeholder { color: rgba(255,255,255,0.5); }
        
        .player-list {
            position: absolute; top: 20px; right: 20px;
            max-width: 250px; font-size: 12px;
            background: rgba(0,0,0,0.7); padding: 10px; border-radius: 10px;
            max-height: 300px; overflow-y: auto;
        }
        
        .player-entry {
            padding: 3px 0; display: flex; justify-content: space-between;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .controls {
            position: absolute; bottom: 20px; right: 20px;
            text-align: right; font-size: 12px; opacity: 0.7;
        }
        
        .start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 200;
            pointer-events: all;
        }
        
        .game-title {
            font-size: 4em; margin-bottom: 20px; text-align: center;
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        
        .start-button {
            padding: 15px 40px; font-size: 1.5em;
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border: none; color: white; border-radius: 30px; cursor: pointer;
            transition: all 0.3s ease; margin-top: 30px;
        }
        
        .start-button:hover { transform: scale(1.1); }
        
        .notification {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(78, 205, 196, 0.2); border: 2px solid rgba(78, 205, 196, 0.8);
            border-radius: 15px; padding: 20px; text-align: center;
            opacity: 0; transition: opacity 0.5s ease; z-index: 150;
        }
        
        .notification.show { opacity: 1; }
        
        .jumpscare {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(255,0,0,0.8) 0%, rgba(0,0,0,0.9) 100%);
            opacity: 0; z-index: 150; transition: opacity 0.1s ease;
        }
        
        .jumpscare.active { opacity: 1; }
        
        .death-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(255,0,0,0.9) 0%, rgba(0,0,0,1) 100%);
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 250; pointer-events: all; color: white;
            animation: deathPulse 2s infinite;
        }
        
        .scoreboard-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); display: none; flex-direction: column;
            justify-content: center; align-items: center; z-index: 240;
            pointer-events: all; color: white; overflow-y: auto;
        }
        
        .scoreboard-title {
            font-size: 3em; margin-bottom: 30px; text-align: center;
            background: linear-gradient(45deg, #4ecdc4, #45b7d1, #96ceb4);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        
        .score-entry {
            background: rgba(255,255,255,0.1); border-radius: 10px;
            padding: 15px 25px; margin: 5px 0; width: 600px; max-width: 90vw;
            display: flex; justify-content: space-between; align-items: center;
            border-left: 4px solid;
        }
        
        .score-entry.rank-1 { border-left-color: #ffd700; background: rgba(255,215,0,0.1); }
        .score-entry.rank-2 { border-left-color: #c0c0c0; background: rgba(192,192,192,0.1); }
        .score-entry.rank-3 { border-left-color: #cd7f32; background: rgba(205,127,50,0.1); }
        
        .score-details {
            display: flex; gap: 20px; font-size: 0.9em; opacity: 0.8;
        }
        
        .current-score {
            font-size: 1.5em; margin: 20px 0;
            padding: 20px; background: rgba(78, 205, 196, 0.2);
            border-radius: 15px; border: 2px solid rgba(78, 205, 196, 0.8);
        }
        
        @keyframes deathPulse {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; filter: contrast(150%) brightness(120%); }
        }
        
        .death-title {
            font-size: 5em; margin-bottom: 20px; text-align: center;
            color: #ff0000; text-shadow: 0 0 30px #ff0000;
            animation: glitch 0.5s infinite;
        }
        
        @keyframes glitch {
            0% { transform: translate(0); }
            10% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
            20% { transform: translate(2px, -2px); filter: hue-rotate(180deg); }
            30% { transform: translate(-2px, -2px); filter: invert(1); }
            40% { transform: translate(2px, 2px); filter: hue-rotate(270deg); }
            50% { transform: translate(0); filter: contrast(200%); }
        }
        
        .radiation-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 140;
            background: radial-gradient(circle, transparent 40%, rgba(255,100,100,0.3) 100%);
            opacity: 0; transition: opacity 0.3s ease;
        }
        
        .radiation-overlay.active { opacity: 1; }
        
        .glitch-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 130;
            background: repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(255,255,255,0.1) 1px, rgba(255,255,255,0.1) 3px);
            opacity: 0; animation: glitchFlicker 0.05s infinite;
            mix-blend-mode: difference;
        }
        
        @keyframes glitchFlicker {
            0% { opacity: 0; transform: translateX(0); }
            10% { opacity: 1; transform: translateX(-5px); filter: hue-rotate(90deg); }
            20% { opacity: 0; transform: translateX(3px); }
            30% { opacity: 1; transform: translateX(-2px); filter: invert(1); }
            40% { opacity: 0; transform: translateX(4px); }
            50% { opacity: 1; transform: translateX(-6px); filter: contrast(200%); }
            60% { opacity: 0; transform: translateX(2px); }
            70% { opacity: 1; transform: translateX(-3px); filter: saturate(300%); }
            80% { opacity: 0; transform: translateX(5px); }
            90% { opacity: 1; transform: translateX(-4px); filter: brightness(300%); }
            100% { opacity: 0; transform: translateX(0); }
        }
        
        .static-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 125;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255,255,255,0.05) 2px, rgba(255,255,255,0.05) 4px);
            opacity: 0; animation: staticNoise 0.1s infinite;
        }
        
        @keyframes staticNoise {
            0% { opacity: 0; }
            10% { opacity: 0.3; filter: contrast(150%); }
            20% { opacity: 0.1; filter: contrast(200%); }
            30% { opacity: 0.4; filter: contrast(80%); }
            40% { opacity: 0.05; filter: contrast(300%); }
            50% { opacity: 0.5; filter: contrast(50%); }
            60% { opacity: 0.2; filter: contrast(250%); }
            70% { opacity: 0.35; filter: contrast(120%); }
            80% { opacity: 0.15; filter: contrast(180%); }
            90% { opacity: 0.45; filter: contrast(90%); }
            100% { opacity: 0; }
        }
        
        .radar {
            position: absolute; bottom: 180px; right: 20px;
            width: 120px; height: 120px; border-radius: 50%;
            background: rgba(0,0,0,0.8); border: 2px solid #4ecdc4;
            pointer-events: none;
        }
        
        .radar-dot {
            position: absolute; width: 4px; height: 4px;
            border-radius: 50%; transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-overlay">
        <div class="connection-status" id="connectionStatus">
            <span class="connecting">Connecting...</span>
        </div>
        
        <div class="hud">
            <div>Position: <span id="coords">0, 0, 0</span></div>
            <div>Score: <span id="score">0</span></div>
            <div>Discoveries: <span id="discoveries">0</span></div>
            <div>Rare Items: <span id="rare">0</span></div>
            <div>Creatures Found: <span id="creatures">0</span></div>
            <div>Players Online: <span id="playerCount">1</span></div>
            <div style="color: #ff6b6b;">Radiation: <span id="radiation">0</span>%</div>
        </div>
        
        <div class="player-list" id="playerList">
            <div style="font-weight: bold; margin-bottom: 5px;">Other Players</div>
            <div style="opacity: 0.7; font-size: 11px;">No other players nearby</div>
        </div>
        
        <div class="controls">
            <div>WASD - Move | QE - Up/Down | Arrow Keys - Look | Shift - Boost</div>
            <div>Enter - Chat | R - Reset | M - Music | V - Voice | S - Scoreboard</div>
        </div>
        
        <div class="chat-container">
            <div class="chat-messages" id="chatMessages"></div>
            <input type="text" class="chat-input" id="chatInput" placeholder="Press Enter to chat..." maxlength="100">
        </div>
        
        <div class="radar" id="radar">
            <div style="position: absolute; top: -20px; left: 50%; transform: translateX(-50%); font-size: 10px;">Players</div>
        </div>
        
        <div class="notification" id="notification">
            <div id="notifText">Welcome!</div>
        </div>
        
        <div class="jumpscare" id="jumpscare"></div>
        <div class="radiation-overlay" id="radiationOverlay"></div>
        <div class="glitch-overlay" id="glitchOverlay"></div>
        <div class="static-overlay" id="staticOverlay"></div>
    </div>
    
    <div class="death-screen" id="deathScreen">
        <h1 class="death-title">RADIATION OVERLOAD</h1>
        <div class="current-score">
            <div style="font-size: 1.2em; margin-bottom: 10px;">Final Score: <span id="finalScore">0</span></div>
            <div>Discoveries: <span id="finalDiscoveries">0</span> | 
                 Rare Items: <span id="finalRare">0</span> | 
                 Creatures: <span id="finalCreatures">0</span></div>
        </div>
        <button class="start-button" onclick="showScoreboard()">View Scoreboard</button>
        <button class="start-button" onclick="restartGame()" style="margin-top: 10px;">Try Again</button>
    </div>
    
    <div class="scoreboard-screen" id="scoreboardScreen">
        <h1 class="scoreboard-title">🏆 High Scores 🏆</h1>
        <div id="scoresList"></div>
        <div style="margin-top: 30px;">
            <button class="start-button" onclick="restartGame()">Play Again</button>
            <button class="start-button" onclick="hideScoreboard()" style="margin-left: 15px;">Back to Game</button>
        </div>
    </div>
    
    <div class="start-screen" id="startScreen">
        <h1 class="game-title">Ethereal Exploration</h1>
        <h2 style="color: #4ecdc4; margin-bottom: 20px;">Multiplayer Edition</h2>
        <p style="text-align: center; max-width: 600px; margin: 20px;">
            Explore infinite space filled with discoveries, exploding creatures, rare entities, and mysterious space creatures!
            But beware - cosmic radiation builds up as you explore. Find the green ring portals to cleanse yourself!
            Chat and interact with other players in real-time - now with voice synthesis!
        </p>
        <button class="start-button" onclick="startGame()">Begin Journey</button>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        console.log('🎮 Starting Ethereal Exploration Multiplayer');
        
        // Global variables
        let scene, camera, renderer;
        let player = { x: 0, y: 0, z: 0, rotationX: 0, rotationY: 0 };
        let keys = {};
        let objects = [];
        let discoveries = 0;
        let rareItems = 0;
        let creaturesFound = 0;
        let score = 0;
        let gameStarted = false;
        let socket;
        let playerId;
        let playerName;
        let chatFocused = false;
        let audioContext, masterGain;
        let musicPlaying = false;
        let ambientOscillators = [];
        
        // 🎤 Text-to-Speech for chat
        let speechSynthesis = window.speechSynthesis;
        let availableVoices = [];
        let chatTTSEnabled = true;
        
        // Load available voices
        function loadVoices() {
            availableVoices = speechSynthesis.getVoices();
            console.log('🎤 Available voices:', availableVoices.length);
            
            // Filter out system voices and keep interesting ones
            availableVoices = availableVoices.filter(voice => {
                // Keep English voices and some interesting international ones
                return voice.lang.startsWith('en') || 
                       voice.lang.includes('fr') || 
                       voice.lang.includes('de') || 
                       voice.lang.includes('it') || 
                       voice.lang.includes('es') ||
                       voice.lang.includes('ja') ||
                       voice.lang.includes('ru');
            });
            
            console.log('🎤 Filtered voices:', availableVoices.length);
        }
        
        // Initialize voices (some browsers need this)
        speechSynthesis.onvoiceschanged = loadVoices;
        loadVoices();
        
        function speakChatMessage(playerName, message) {
            if (!chatTTSEnabled || !speechSynthesis || availableVoices.length === 0) return;
            
            // Don't speak system messages or own messages
            if (playerName === 'System' || playerName === 'You') return;
            
            // Create speech utterance
            const utterance = new SpeechSynthesisUtterance(message);
            
            // 🎲 Random voice selection
            const randomVoice = availableVoices[Math.floor(Math.random() * availableVoices.length)];
            utterance.voice = randomVoice;
            
            // 🎵 Random pitch and rate for variety
            utterance.pitch = 0.6 + Math.random() * 0.8; // 0.6 to 1.4
            utterance.rate = 0.7 + Math.random() * 0.6;  // 0.7 to 1.3
            utterance.volume = 0.6 + Math.random() * 0.3; // 0.6 to 0.9
            
            // 🎭 Sometimes make it extra weird
            if (Math.random() < 0.1) { // 10% chance
                utterance.pitch = 0.3 + Math.random() * 1.4; // Very wide range
                utterance.rate = 0.5 + Math.random() * 1.0;  // Slow to fast
            }
            
            // 🎨 Visual feedback while speaking
            const notificationText = `🎤 ${playerName} (${randomVoice.name.split(' ')[0]})`;
            showNotification(notificationText, 2000);
            
            // Error handling
            utterance.onerror = (event) => {
                console.warn('🎤 Speech error:', event.error);
            };
            
            utterance.onstart = () => {
                console.log(`🎤 Speaking: "${message}" in ${randomVoice.name} voice`);
            };
            
            // Cancel any ongoing speech and speak new message
            speechSynthesis.cancel();
            speechSynthesis.speak(utterance);
        }
        
        function toggleChatTTS() {
            chatTTSEnabled = !chatTTSEnabled;
            if (chatTTSEnabled) {
                showNotification('🎤 Chat voice enabled!', 2000);
                addChatMessage('System', 'Chat voice enabled! Messages will be spoken aloud.');
            } else {
                showNotification('🔇 Chat voice disabled', 2000);
                addChatMessage('System', 'Chat voice disabled.');
                speechSynthesis.cancel(); // Stop any ongoing speech
            }
        }
        
        // Radiation system - CHANGE THESE VALUES TO ADJUST RADIATION
        let radiationLevel = 0;
        let maxRadiation = 100;
        let radiationRate = 0.02; // 🔧 RADIATION RATE: Lower = slower radiation buildup (0.02 = slow, 0.05 = fast)
        let lastJumpscareTime = 0;
        
        // Scoring system
        const POINTS = {
            discovery: 10,
            explosion: 15,
            rareEntity: 50,
            spaceCreature: 25,
            portalUsed: 5,
            survivalBonus: 2
        };
        
        let gameStartTime = 0;
        let survivalTime = 0;
        
        // Multiplayer
        let otherPlayers = new Map();
        let playerDots = [];
        
        // 🔧 WORLD GENERATION SETTINGS - CHANGE THESE VALUES
        const WORLD_SETTINGS = {
            discoveries: 60,
            explodingCreatures: 40,
            rareEntities: 15,
            spaceCreatures: 20,
            ringPortals: 12, // 🔧 PORTAL COUNT: Change this number to adjust portal availability
            viewDistance: 800, // 🔧 VIEWING DISTANCE: Reduced from 1000 to 800 for closer gameplay
            worldSize: 2500
        };
        
        function startGame() {
            console.log('🚀 Starting game...');
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('deathScreen').style.display = 'none';
            document.getElementById('scoreboardScreen').style.display = 'none';
            gameStarted = true;
            gameStartTime = Date.now();
            
            // Reset game state
            player = { x: 0, y: 0, z: 0, rotationX: 0, rotationY: 0 };
            discoveries = 0;
            rareItems = 0;
            creaturesFound = 0;
            score = 0;
            radiationLevel = 0;
            survivalTime = 0;
            
            // Clear objects
            objects.forEach(obj => scene.remove(obj));
            objects = [];
            
            // Reset camera
            camera.position.set(0, 0, 0);
            camera.rotation.set(0, 0, 0);
            
            // Generate world and start systems
            generateWorld();
            startMusic();
            initSocket();
        }
        
        function restartGame() {
            startGame();
        }
        
        function showScoreboard() {
            document.getElementById('deathScreen').style.display = 'none';
            document.getElementById('scoreboardScreen').style.display = 'flex';
            displayScoreboard();
        }
        
        function hideScoreboard() {
            document.getElementById('scoreboardScreen').style.display = 'none';
        }
        
        function initSocket() {
            console.log('🔌 Connecting to server...');
            document.getElementById('connectionStatus').innerHTML = '<span class="connecting">Connecting...</span>';
            
            socket = io();
            
            socket.on('connect', () => {
                console.log('✅ Connected to server:', socket.id);
                document.getElementById('connectionStatus').innerHTML = '<span class="connected">Connected</span>';
                showNotification('Connected to competitive multiplayer server!');
                addChatMessage('System', 'Connected! Compete with other players for resources!');
            });
            
            socket.on('disconnect', () => {
                console.log('❌ Disconnected from server');
                document.getElementById('connectionStatus').innerHTML = '<span class="disconnected">Disconnected</span>';
                addChatMessage('System', 'Disconnected from server - world resources disabled');
            });
            
            socket.on('connect_error', (error) => {
                console.log('❌ Connection error:', error);
                document.getElementById('connectionStatus').innerHTML = '<span class="disconnected">Connection Failed</span>';
                addChatMessage('System', 'Failed to connect to server - using local world only');
            });
            
            socket.on('player_init', (data) => {
                console.log('👤 Player initialized:', data);
                playerId = data.id;
                playerName = data.name;
                player.x = data.x;
                player.y = data.y;
                player.z = data.z;
                camera.position.set(player.x, player.y, player.z);
                addChatMessage('System', `You are ${playerName} - find resources before others do!`);
                
                // Start sending position updates
                setInterval(() => {
                    if (socket && socket.connected && gameStarted) {
                        socket.emit('player_update', {
                            x: player.x,
                            y: player.y,
                            z: player.z,
                            rotationX: player.rotationX,
                            rotationY: player.rotationY,
                            radiationLevel: radiationLevel
                        });
                    }
                }, 100);
            });
            
            socket.on('world_sync', (data) => {
                console.log('🌍 World sync received:', data.objects.length, 'objects');
                syncWorldObjects(data.objects);
            });
            
            socket.on('game_state', (data) => {
                if (!data) return;
                
                if (data.players) {
                    updateOtherPlayers(data.players);
                    updatePlayerList(data.players);
                    updatePlayerDots(data.players);
                }
                
                // 🚫 OBJEKT-UPDATES DEAKTIVIERT für bessere Performance
                // if (data.objects) {
                //     updateNearbyObjects(data.objects);
                // }
                
                // 🚫 SERVER STATS DEAKTIVIERT - Alles client-side für sofortiges Feedback
                // if (data.yourStats) {
                //     updatePlayerStats(data.yourStats);
                // }
                
                if (data.totalPlayers) updatePlayerCount(data.totalPlayers);
            });
            
            socket.on('collection_result', (data) => {
                console.log('🎯 Collection result:', data);
                // Only handle theft scenarios now, since collection is client-side
                if (!data.success && data.reason === 'stolen') {
                    playSound(150); // Disappointment sound
                    showNotification(`😤 ${data.stolenBy} stole your resource! (They were ${data.thiefDistance}m away, you were ${data.yourDistance}m)`, 5000);
                    addChatMessage('System', `🏴‍☠️ ${data.stolenBy} stole a resource from you!`);
                } else if (data.success && data.competitorCount > 0) {
                    showNotification(`💪 ${data.message}`, 3000);
                }
            });
            
            socket.on('creature_moved', (data) => {
                console.log('🏃 Creature moved:', data);
                
                // Find the creature and update its position
                const creature = objects.find(obj => obj.userData.serverId === data.objectId);
                if (creature) {
                    // Smooth movement update
                    creature.position.set(data.newPosition.x, data.newPosition.y, data.newPosition.z);
                    creature.userData.fleeing = data.fleeing;
                    console.log(`🔄 Updated creature ${data.objectId} position from server`);
                }
            });
            
            socket.on('resource_stolen', (data) => {
                console.log('🏴‍☠️ Resource stolen:', data);
                if (data.thief !== playerName && data.victim !== playerName) {
                    // Show notification about other players' theft
                    showNotification(`🏴‍☠️ ${data.thief} stole from ${data.victim}!`, 3000);
                }
                addChatMessage('System', `🏴‍☠️ ${data.thief} stole a ${data.objectType} from ${data.victim}! (+${data.points} points)`);
            });
            
            socket.on('resource_collected', (data) => {
                console.log('✅ Resource collected:', data);
                if (data.collector !== playerName) {
                    addChatMessage('System', `${data.collector} found a ${data.objectType}! (+${data.points} points)${data.competitorCount > 0 ? ` (beat ${data.competitorCount} competitors)` : ''}`);
                }
            });
            
            socket.on('leaderboard_update', (data) => {
                console.log('🏆 Leaderboard update:', data.leaderboard);
                updateLeaderboard(data.leaderboard);
            });
            
            socket.on('chat_message', (data) => {
                console.log('💬 Chat message received:', data);
                addChatMessage(data.playerName, data.message);
                
                // 🎤 Speak the message with random voice!
                speakChatMessage(data.playerName, data.message);
                
                if (data.playerId !== playerId) {
                    showNotification(`💬 ${data.playerName}: ${data.message}`, 3000);
                }
            });
            
            socket.on('player_joined', (data) => {
                console.log('👋 Player joined:', data);
                addChatMessage('System', `${data.name} joined the competition!`);
                updatePlayerCount(data.totalPlayers);
            });
            
            socket.on('player_left', (data) => {
                console.log('👋 Player left:', data);
                addChatMessage('System', `${data.name} left the game`);
                updatePlayerCount(data.totalPlayers);
            });
        }
        
        function syncWorldObjects(serverObjects) {
            console.log('🔄 Syncing world objects from server...');
            
            // Clear existing local objects
            objects.forEach(obj => scene.remove(obj));
            objects = [];
            
            // Create objects based on server data
            serverObjects.forEach(objData => {
                if (objData.available) {
                    const obj = createObjectFromData(objData);
                    if (obj) {
                        scene.add(obj);
                        objects.push(obj);
                    }
                }
            });
            
            console.log(`✅ Synced ${objects.length} world objects`);
        }
        
        function createObjectFromData(objData) {
            let obj;
            
            switch(objData.type) {
                case 'discovery':
                    obj = createDiscoveryFromData(objData);
                    break;
                case 'exploding':
                    obj = createExplodingCreatureFromData(objData);
                    break;
                case 'rare':
                    obj = createRareEntityFromData(objData);
                    break;
                case 'spaceCreature':
                    obj = createSpaceCreatureFromData(objData);
                    break;
                case 'ringPortal':
                    obj = createRingPortalFromData(objData);
                    break;
                default:
                    return null;
            }
            
            if (obj) {
                obj.userData.serverId = objData.id;
                // 🚫 KEIN serverManaged Flag mehr - alles ist client-side!
                console.log(`✅ Created ${objData.type} with client-side management`);
            }
            
            return obj;
        }
        
        function createDiscoveryFromData(objData) {
            const geometry = new THREE.SphereGeometry(8, 16, 16);
            const material = new THREE.MeshLambertMaterial({
                color: Math.random() * 0xffffff,
                transparent: true,
                opacity: 0.8,
                emissive: new THREE.Color(Math.random() * 0x444444)
            });
            
            const discovery = new THREE.Mesh(geometry, material);
            discovery.position.set(objData.x, objData.y, objData.z);
            discovery.userData = { type: 'discovery', collected: false };
            
            return discovery;
        }
        
        function createExplodingCreatureFromData(objData) {
            const geometries = [
                new THREE.TetrahedronGeometry(10, 1),
                new THREE.OctahedronGeometry(10, 1),
                new THREE.IcosahedronGeometry(8, 1)
            ];
            
            const geometry = geometries[Math.floor(Math.random() * geometries.length)];
            const hue = objData.hue || Math.random();
            const material = new THREE.MeshLambertMaterial({
                color: new THREE.Color().setHSL(hue, 0.8, 0.5),
                emissive: new THREE.Color().setHSL(hue, 0.6, 0.2)
            });
            
            const creature = new THREE.Mesh(geometry, material);
            creature.position.set(objData.x, objData.y, objData.z);
            creature.userData = { 
                type: 'exploding', 
                exploded: false, 
                hue: hue,
                originalY: objData.y,
                rotSpeed: 0.02 + Math.random() * 0.03
            };
            
            return creature;
        }
        
        function createRareEntityFromData(objData) {
            const geometry = new THREE.DodecahedronGeometry(12, 0);
            const material = new THREE.MeshLambertMaterial({
                color: 0xffd700,
                emissive: 0x333300,
                wireframe: Math.random() > 0.5
            });
            
            const entity = new THREE.Mesh(geometry, material);
            entity.position.set(objData.x, objData.y, objData.z);
            entity.userData = { 
                type: 'rare', 
                collected: false,
                originalY: objData.y,
                fleeSpeed: 0.8
            };
            
            return entity;
        }
        
        function createSpaceCreatureFromData(objData) {
            const creature = new THREE.Group();
            const bodySize = 8 + Math.random() * 12;
            const hue = Math.random();
            
            // Body
            const bodyGeometry = new THREE.SphereGeometry(bodySize, 12, 8);
            const bodyMaterial = new THREE.MeshLambertMaterial({
                color: new THREE.Color().setHSL(hue, 0.7, 0.5),
                transparent: true,
                opacity: 0.9,
                emissive: new THREE.Color().setHSL(hue, 0.4, 0.1)
            });
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            creature.add(body);
            
            // Tentacles
            const tentacleCount = objData.tentacleCount || (3 + Math.floor(Math.random() * 5));
            for (let i = 0; i < tentacleCount; i++) {
                const tentacleGeometry = new THREE.CylinderGeometry(bodySize * 0.1, bodySize * 0.05, bodySize * 2, 6);
                const tentacleMaterial = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(hue + 0.1, 0.6, 0.4),
                    transparent: true,
                    opacity: 0.8
                });
                
                const tentacle = new THREE.Mesh(tentacleGeometry, tentacleMaterial);
                
                const angle = (i / tentacleCount) * Math.PI * 2;
                tentacle.position.set(
                    Math.cos(angle) * bodySize * 0.7,
                    -bodySize,
                    Math.sin(angle) * bodySize * 0.7
                );
                
                creature.add(tentacle);
            }
            
            creature.position.set(objData.x, objData.y, objData.z);
            creature.userData = {
                type: 'spaceCreature',
                originalY: objData.y,
                swimSpeed: 0.3 + Math.random() * 0.5,
                touched: false,
                tentacleCount: tentacleCount,
                fleeSpeed: 0.7 + Math.random() * 0.2, // 🔧 Slower flee speed - catchable!
                detectionRange: 80 + Math.random() * 40,
                fleeing: false
            };
            
            return creature;
        }
        
        function createRingPortalFromData(objData) {
            const portal = new THREE.Group();
            
            const outerRing = new THREE.Mesh(
                new THREE.TorusGeometry(25, 3, 8, 32),
                new THREE.MeshLambertMaterial({
                    color: 0x00ff88,
                    emissive: 0x004422,
                    transparent: true,
                    opacity: 0.8
                })
            );
            
            const innerRing = new THREE.Mesh(
                new THREE.TorusGeometry(18, 1.5, 8, 32),
                new THREE.MeshLambertMaterial({
                    color: 0x88ff00,
                    emissive: 0x224400,
                    transparent: true,
                    opacity: 0.9
                })
            );
            
            portal.add(outerRing);
            portal.add(innerRing);
            
            portal.position.set(objData.x, objData.y, objData.z);
            portal.userData = {
                type: 'ringPortal',
                used: false
            };
            
            return portal;
        }
        
        function updateNearbyObjects(serverObjects) {
            // 🚫 DEAKTIVIERT - Wir wollen KEINE Server-Updates für Objekte mehr!
            // Server soll nur für Diebstahl-Validierung verwendet werden
            console.log('📦 Server object update received but ignored for client performance');
            
            /* 
            ALTE LOGIK AUSKOMMENTIERT:
            // This function updates the visual state of nearby objects
            // based on server data (like if they've been collected by others)
            serverObjects.forEach(serverObj => {
                const localObj = objects.find(obj => obj.userData.serverId === serverObj.id);
                if (localObj && !serverObj.available && localObj.visible) {
                    // Object was collected by someone else - hide it locally
                    scene.remove(localObj);
                    const index = objects.indexOf(localObj);
                    if (index > -1) objects.splice(index, 1);
                    console.log(`👻 Object ${serverObj.type} removed - collected by someone else`);
                }
            });
            */
        }
        
        function updatePlayerStats(stats) {
            console.log('📊 Updating player stats from server:', stats);
            
            // Update local stats from server
            score = stats.score;
            discoveries = stats.discoveries;
            rareItems = stats.rareItems;
            creaturesFound = stats.creatures;
            radiationLevel = stats.radiationLevel;
            
            // Update HUD elements
            document.getElementById('score').textContent = score;
            document.getElementById('discoveries').textContent = discoveries;
            document.getElementById('rare').textContent = rareItems;
            document.getElementById('creatures').textContent = creaturesFound;
            document.getElementById('radiation').textContent = Math.round(radiationLevel);
            
            // Update radiation color
            const radiationElement = document.getElementById('radiation');
            if (radiationLevel < 30) {
                radiationElement.style.color = '#4ecdc4';
                radiationElement.style.textShadow = 'none';
            } else if (radiationLevel < 60) {
                radiationElement.style.color = '#ffd93d';
                radiationElement.style.textShadow = 'none';
            } else if (radiationLevel < 85) {
                radiationElement.style.color = '#ff6b6b';
                radiationElement.style.textShadow = 'none';
            } else {
                radiationElement.style.color = '#ff0000';
                radiationElement.style.textShadow = '0 0 10px #ff0000';
            }
            
            // Show additional competitive stats in console
            if (stats.resourcesStolen > 0 || stats.resourcesLost > 0) {
                console.log(`🏴‍☠️ Competitive stats: ${stats.resourcesStolen} stolen, ${stats.resourcesLost} lost`);
            }
        }
        
        function updateLeaderboard(leaderboard) {
            // Could display this in a leaderboard UI element
            console.log('🏆 Current leaderboard:', leaderboard);
            
            // For now, just show top player in chat occasionally
            if (leaderboard.length > 0) {
                const leader = leaderboard[0];
                if (Math.random() < 0.1) { // 10% chance to show leader update
                    addChatMessage('System', `👑 Current leader: ${leader.name} with ${leader.score} points (${leader.resourcesStolen} steals)`);
                }
            }
        }
        
        function updateOtherPlayers(players) {
            console.log('👥 Updating other players:', players.length, 'players received');
            
            if (!players || players.length === 0) {
                console.log('❌ No players data received');
                return;
            }
            
            // Remove old players that are no longer in the list
            for (const [id, playerObj] of otherPlayers) {
                if (!players.find(p => p.id === id)) {
                    console.log(`➖ Removing player ${playerObj.data.name} from scene`);
                    scene.remove(playerObj.mesh);
                    otherPlayers.delete(id);
                }
            }
            
            // Add/update players
            players.forEach(playerData => {
                let playerObj = otherPlayers.get(playerData.id);
                
                if (!playerObj) {
                    console.log(`🎨 Creating 3D mesh for ${playerData.name} at distance ${playerData.distance}m`);
                    
                    const group = new THREE.Group();
                    
                    // Main body
                    const bodyGeometry = new THREE.CylinderGeometry(3, 3, 12, 8);
                    const bodyMaterial = new THREE.MeshLambertMaterial({
                        color: playerData.color,
                        emissive: new THREE.Color(playerData.color).multiplyScalar(0.4)
                    });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    group.add(body);
                    
                    // Head
                    const headGeometry = new THREE.SphereGeometry(2.5, 8, 6);
                    const headMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color(playerData.color).multiplyScalar(1.2),
                        emissive: new THREE.Color(playerData.color).multiplyScalar(0.3)
                    });
                    const head = new THREE.Mesh(headGeometry, headMaterial);
                    head.position.y = 8;
                    group.add(head);
                    
                    // Glowing top sphere
                    const glowGeometry = new THREE.SphereGeometry(4, 8, 6);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: playerData.color,
                        emissive: new THREE.Color(playerData.color).multiplyScalar(0.8)
                    });
                    const glowSphere = new THREE.Mesh(glowGeometry, glowMaterial);
                    glowSphere.position.y = 15;
                    group.add(glowSphere);
                    
                    // Name label above player
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 256;
                    canvas.height = 64;
                    context.fillStyle = '#ffffff';
                    context.font = '24px Arial';
                    context.textAlign = 'center';
                    context.fillText(playerData.name, 128, 40);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const labelMaterial = new THREE.SpriteMaterial({ map: texture });
                    const label = new THREE.Sprite(labelMaterial);
                    label.position.y = 25;
                    label.scale.set(20, 5, 1);
                    group.add(label);
                    
                    group.position.set(playerData.x, playerData.y, playerData.z);
                    scene.add(group);
                    
                    playerObj = { mesh: group, data: playerData };
                    otherPlayers.set(playerData.id, playerObj);
                    
                    showNotification(`👋 ${playerData.name} is ${playerData.distance}m away!`, 4000);
                    addChatMessage('System', `🎯 ${playerData.name} appeared at distance ${playerData.distance}m`);
                } else {
                    // Update existing player position
                    console.log(`🔄 Moving ${playerData.name} to (${Math.round(playerData.x)}, ${Math.round(playerData.y)}, ${Math.round(playerData.z)}) - ${playerData.distance}m away`);
                    playerObj.mesh.position.set(playerData.x, playerData.y, playerData.z);
                    playerObj.data = playerData;
                }
            });
            
            console.log(`👥 Scene now has ${otherPlayers.size} other players visible`);
            console.log(`📷 Your position: (${Math.round(player.x)}, ${Math.round(player.y)}, ${Math.round(player.z)})`);
        }
        
        function updatePlayerDots(players) {
            console.log('📡 Updating radar with players:', players);
            playerDots = players.map(p => ({
                x: p.x,
                y: p.y,
                z: p.z,
                color: p.color,
                name: p.name,
                distance: p.distance
            }));
            updateRadar();
        }
        
        function updatePlayerCount(count) {
            document.getElementById('playerCount').textContent = count;
        }
        
        function updatePlayerList(players) {
            const playerList = document.getElementById('playerList');
            let html = '<div style="font-weight: bold; margin-bottom: 5px;">Other Players</div>';
            
            if (!players || players.length === 0) {
                html += '<div style="opacity: 0.7; font-size: 11px;">No other players nearby</div>';
            } else {
                console.log('📝 Updating player list with', players.length, 'players');
                players.forEach(p => {
                    const colorHex = p.color ? p.color.toString(16).padStart(6, '0') : 'ffffff';
                    html += `
                        <div class="player-entry">
                            <span style="color: #${colorHex}">${p.name || 'Unknown'}</span>
                            <span>${p.distance || '?'}m away</span>
                        </div>
                    `;
                });
            }
            playerList.innerHTML = html;
        }
        
        function updateRadar() {
            const radar = document.getElementById('radar');
            if (!radar) return;
            
            // Clear existing dots
            radar.querySelectorAll('.radar-dot').forEach(dot => dot.remove());
            
            const radarRadius = 60; // Radius of the radar display
            const maxDistance = 1000; // Maximum distance to show on radar
            
            console.log('🎯 Updating radar with', playerDots.length, 'player dots');
            
            playerDots.forEach(dot => {
                const dx = dot.x - player.x;
                const dy = dot.y - player.y;
                const dz = dot.z - player.z;
                const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                if (distance > 0 && distance < maxDistance) {
                    // Calculate angle from player's perspective
                    const angle = Math.atan2(dz, dx);
                    const normalizedDistance = Math.min(distance / maxDistance, 1);
                    
                    // Calculate position on radar circle
                    const radarX = Math.cos(angle) * normalizedDistance * radarRadius + radarRadius;
                    const radarY = Math.sin(angle) * normalizedDistance * radarRadius + radarRadius;
                    
                    // Create dot element
                    const dotElement = document.createElement('div');
                    dotElement.className = 'radar-dot';
                    dotElement.style.left = radarX + 'px';
                    dotElement.style.top = radarY + 'px';
                    dotElement.style.backgroundColor = `#${dot.color.toString(16).padStart(6, '0')}`;
                    dotElement.style.boxShadow = `0 0 4px #${dot.color.toString(16).padStart(6, '0')}`;
                    dotElement.title = `${dot.name} (${Math.round(distance)}m)`;
                    
                    radar.appendChild(dotElement);
                    console.log(`📍 Added radar dot for ${dot.name} at distance ${Math.round(distance)}m`);
                }
            });
        }
        
        function addChatMessage(playerName, message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageElement = document.createElement('div');
            
            const timestamp = new Date().toLocaleTimeString('en-US', { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            // Add voice indicator for TTS-enabled messages
            const voiceIndicator = (chatTTSEnabled && playerName !== 'System' && playerName !== 'You') ? '🎤 ' : '';
            
            messageElement.innerHTML = `<span style="color: #666; font-size: 10px;">[${timestamp}]</span> ${voiceIndicator}<strong style="color: #4ecdc4">${playerName}:</strong> ${message}`;
            messageElement.style.marginBottom = '3px';
            messageElement.style.wordWrap = 'break-word';
            
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            while (chatMessages.children.length > 50) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
        }
        
        function showNotification(text, duration = 3000) {
            const notif = document.getElementById('notification');
            document.getElementById('notifText').textContent = text;
            notif.classList.add('show');
            setTimeout(() => notif.classList.remove('show'), duration);
        }
        
        function addScore(points) {
            score += points;
        }
        
        function saveScore() {
            const playerScore = {
                score: score,
                discoveries: discoveries,
                rareItems: rareItems,
                creatures: creaturesFound,
                survivalTime: Math.floor(survivalTime / 1000),
                date: new Date().toLocaleDateString()
            };
            
            let scores = JSON.parse(localStorage.getItem('etherealExplorationScores') || '[]');
            scores.push(playerScore);
            scores.sort((a, b) => b.score - a.score);
            scores = scores.slice(0, 10);
            localStorage.setItem('etherealExplorationScores', JSON.stringify(scores));
        }
        
        function displayScoreboard() {
            const scores = JSON.parse(localStorage.getItem('etherealExplorationScores') || '[]');
            const scoresList = document.getElementById('scoresList');
            
            if (scores.length === 0) {
                scoresList.innerHTML = '<div style="text-align: center; opacity: 0.7; font-size: 1.2em;">No scores yet! Be the first to play.</div>';
                return;
            }
            
            let html = '';
            scores.forEach((score, index) => {
                const rankClass = index === 0 ? 'rank-1' : index === 1 ? 'rank-2' : index === 2 ? 'rank-3' : '';
                const rankIcon = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `#${index + 1}`;
                
                html += `
                    <div class="score-entry ${rankClass}">
                        <div>
                            <span style="font-size: 1.1em; font-weight: bold;">${rankIcon} ${score.score} points</span>
                            <div class="score-details">
                                <span>💎 ${score.discoveries}</span>
                                <span>⭐ ${score.rareItems}</span>
                                <span>🐙 ${score.creatures}</span>
                                <span>⏱️ ${score.survivalTime}s</span>
                                <span>📅 ${score.date}</span>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            scoresList.innerHTML = html;
        }
        
        function triggerRadiationDeath() {
            gameStarted = false;
            
            // Calculate final score
            const finalSurvivalScore = Math.floor(survivalTime / 1000) * POINTS.survivalBonus;
            score = discoveries * POINTS.discovery + 
                   rareItems * POINTS.rareEntity + 
                   creaturesFound * POINTS.spaceCreature + 
                   finalSurvivalScore;
            
            // Save score to leaderboard
            saveScore();
            
            // Show final stats
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalDiscoveries').textContent = discoveries;
            document.getElementById('finalRare').textContent = rareItems;
            document.getElementById('finalCreatures').textContent = creaturesFound;
            
            // Play death sound
            playDeathSound();
            
            // Show death screen
            document.getElementById('deathScreen').style.display = 'flex';
            
            // Notify other players
            if (socket && socket.connected) {
                addChatMessage('System', `💀 You died from radiation poisoning! Final score: ${score}`);
            }
        }
        
        function init() {
            console.log('🎨 Initializing 3D scene...');
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, WORLD_SETTINGS.viewDistance * 2);
            
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,
                alpha: false
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000510, 1);
            
            canvas.style.width = '100vw';
            canvas.style.height = '100vh';
            canvas.style.position = 'fixed';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.zIndex = '1';
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Audio context
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.connect(audioContext.destination);
                masterGain.gain.setValueAtTime(0.3, audioContext.currentTime);
            } catch (e) {
                console.warn('Audio not available:', e);
            }
            
            // Create stars
            createStars();
            
            // Setup controls
            setupControls();
            
            // Start animation loop
            animate();
            
            console.log('✅ 3D scene initialized');
        }
        
        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 2000;
            const positions = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 4000;
                positions[i + 1] = (Math.random() - 0.5) * 4000;
                positions[i + 2] = (Math.random() - 0.5) * 4000;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const stars = new THREE.Points(starGeometry, new THREE.PointsMaterial({ color: 0xffffff, size: 2 }));
            scene.add(stars);
        }
        
        function generateWorld() {
            console.log('🌍 Generating world...');
            
            // Create discoveries
            for (let i = 0; i < WORLD_SETTINGS.discoveries; i++) {
                createDiscovery(
                    (Math.random() - 0.5) * WORLD_SETTINGS.worldSize,
                    (Math.random() - 0.5) * 600,
                    (Math.random() - 0.5) * WORLD_SETTINGS.worldSize
                );
            }
            
            // Create exploding creatures
            for (let i = 0; i < WORLD_SETTINGS.explodingCreatures; i++) {
                createExplodingCreature(
                    (Math.random() - 0.5) * WORLD_SETTINGS.worldSize,
                    (Math.random() - 0.5) * 600,
                    (Math.random() - 0.5) * WORLD_SETTINGS.worldSize
                );
            }
            
            // Create rare entities
            for (let i = 0; i < WORLD_SETTINGS.rareEntities; i++) {
                createRareEntity(
                    (Math.random() - 0.5) * WORLD_SETTINGS.worldSize,
                    (Math.random() - 0.5) * 600,
                    (Math.random() - 0.5) * WORLD_SETTINGS.worldSize
                );
            }
            
            // Create space creatures
            for (let i = 0; i < WORLD_SETTINGS.spaceCreatures; i++) {
                createSpaceCreature(
                    (Math.random() - 0.5) * WORLD_SETTINGS.worldSize,
                    (Math.random() - 0.5) * 600,
                    (Math.random() - 0.5) * WORLD_SETTINGS.worldSize
                );
            }
            
            // Create ring portals
            for (let i = 0; i < WORLD_SETTINGS.ringPortals; i++) {
                createRingPortal(
                    (Math.random() - 0.5) * WORLD_SETTINGS.worldSize,
                    (Math.random() - 0.5) * 600,
                    (Math.random() - 0.5) * WORLD_SETTINGS.worldSize
                );
            }
            
            console.log('✅ World generated with', objects.length, 'objects');
        }
        
        function createDiscovery(x, y, z) {
            const geometry = new THREE.SphereGeometry(8, 16, 16);
            const material = new THREE.MeshLambertMaterial({
                color: Math.random() * 0xffffff,
                transparent: true,
                opacity: 0.8,
                emissive: new THREE.Color(Math.random() * 0x444444)
            });
            
            const discovery = new THREE.Mesh(geometry, material);
            discovery.position.set(x, y, z);
            discovery.userData = { type: 'discovery', collected: false };
            
            scene.add(discovery);
            objects.push(discovery);
        }
        
        function createExplodingCreature(x, y, z) {
            const geometries = [
                new THREE.TetrahedronGeometry(10, 1),
                new THREE.OctahedronGeometry(10, 1),
                new THREE.IcosahedronGeometry(8, 1)
            ];
            
            const geometry = geometries[Math.floor(Math.random() * geometries.length)];
            const hue = Math.random();
            const material = new THREE.MeshLambertMaterial({
                color: new THREE.Color().setHSL(hue, 0.8, 0.5),
                emissive: new THREE.Color().setHSL(hue, 0.6, 0.2)
            });
            
            const creature = new THREE.Mesh(geometry, material);
            creature.position.set(x, y, z);
            creature.userData = { 
                type: 'exploding', 
                exploded: false, 
                hue: hue,
                originalY: y,
                rotSpeed: 0.02 + Math.random() * 0.03
            };
            
            scene.add(creature);
            objects.push(creature);
        }
        
        function createRareEntity(x, y, z) {
            const geometry = new THREE.DodecahedronGeometry(12, 0);
            const material = new THREE.MeshLambertMaterial({
                color: 0xffd700,
                emissive: 0x333300,
                wireframe: Math.random() > 0.5
            });
            
            const entity = new THREE.Mesh(geometry, material);
            entity.position.set(x, y, z);
            entity.userData = { 
                type: 'rare', 
                collected: false,
                originalY: y,
                fleeSpeed: 0.8
            };
            
            scene.add(entity);
            objects.push(entity);
        }
        
        function createSpaceCreature(x, y, z) {
            const creature = new THREE.Group();
            const bodySize = 8 + Math.random() * 12;
            const hue = Math.random();
            
            // Body
            const bodyGeometry = new THREE.SphereGeometry(bodySize, 12, 8);
            const bodyMaterial = new THREE.MeshLambertMaterial({
                color: new THREE.Color().setHSL(hue, 0.7, 0.5),
                transparent: true,
                opacity: 0.9,
                emissive: new THREE.Color().setHSL(hue, 0.4, 0.1)
            });
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            creature.add(body);
            
            // Tentacles
            const tentacleCount = 3 + Math.floor(Math.random() * 5);
            for (let i = 0; i < tentacleCount; i++) {
                const tentacleGeometry = new THREE.CylinderGeometry(bodySize * 0.1, bodySize * 0.05, bodySize * 2, 6);
                const tentacleMaterial = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(hue + 0.1, 0.6, 0.4),
                    transparent: true,
                    opacity: 0.8
                });
                
                const tentacle = new THREE.Mesh(tentacleGeometry, tentacleMaterial);
                
                const angle = (i / tentacleCount) * Math.PI * 2;
                tentacle.position.set(
                    Math.cos(angle) * bodySize * 0.7,
                    -bodySize,
                    Math.sin(angle) * bodySize * 0.7
                );
                
                creature.add(tentacle);
            }
            
            creature.position.set(x, y, z);
            creature.userData = {
                type: 'spaceCreature',
                originalY: y,
                swimSpeed: 0.3 + Math.random() * 0.5,
                touched: false,
                tentacleCount: tentacleCount,
                fleeSpeed: 1.1 + Math.random() * 0.3,
                detectionRange: 80 + Math.random() * 40,
                fleeing: false
            };
            
            scene.add(creature);
            objects.push(creature);
        }
        
        function createRingPortal(x, y, z) {
            const portal = new THREE.Group();
            
            const outerRing = new THREE.Mesh(
                new THREE.TorusGeometry(25, 3, 8, 32),
                new THREE.MeshLambertMaterial({
                    color: 0x00ff88,
                    emissive: 0x004422,
                    transparent: true,
                    opacity: 0.8
                })
            );
            
            const innerRing = new THREE.Mesh(
                new THREE.TorusGeometry(18, 1.5, 8, 32),
                new THREE.MeshLambertMaterial({
                    color: 0x88ff00,
                    emissive: 0x224400,
                    transparent: true,
                    opacity: 0.9
                })
            );
            
            portal.add(outerRing);
            portal.add(innerRing);
            
            portal.position.set(x, y, z);
            portal.userData = {
                type: 'ringPortal',
                used: false
            };
            
            scene.add(portal);
            objects.push(portal);
        }
        
        function setupControls() {
            document.addEventListener('keydown', (e) => {
                if (chatFocused && e.code !== 'Enter' && e.code !== 'Escape') return;
                
                keys[e.code] = true;
                
                if (e.code === 'KeyR') {
                    player.x = 0;
                    player.y = 0;
                    player.z = 0;
                    player.rotationX = 0;
                    player.rotationY = 0;
                    camera.position.set(0, 0, 0);
                    camera.rotation.set(0, 0, 0);
                    radiationLevel = 0;
                }
                
                if (e.code === 'KeyM') toggleMusic();
                if (e.code === 'KeyV') toggleChatTTS(); // 🎤 V key for voice toggle
                
                if (e.code === 'KeyS' && !gameStarted) {
                    if (document.getElementById('scoreboardScreen').style.display === 'flex') {
                        hideScoreboard();
                    } else {
                        document.getElementById('startScreen').style.display = 'none';
                        showScoreboard();
                    }
                }
                
                if (e.code === 'Enter') {
                    const chatInput = document.getElementById('chatInput');
                    if (!chatFocused) {
                        chatInput.focus();
                        chatFocused = true;
                        e.preventDefault();
                    } else {
                        const message = chatInput.value.trim();
                        if (message) {
                            if (socket && socket.connected) {
                                console.log('📤 Sending chat message:', message);
                                socket.emit('chat_message', { message });
                            } else {
                                addChatMessage('You', message);
                                addChatMessage('System', 'Not connected to server');
                            }
                            chatInput.value = '';
                        }
                        chatInput.blur();
                        chatFocused = false;
                        e.preventDefault();
                    }
                }
                
                if (e.code === 'Escape' && chatFocused) {
                    const chatInput = document.getElementById('chatInput');
                    chatInput.value = '';
                    chatInput.blur();
                    chatFocused = false;
                    e.preventDefault();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });
            
            document.getElementById('chatInput').addEventListener('focus', () => {
                chatFocused = true;
            });
            
            document.getElementById('chatInput').addEventListener('blur', () => {
                chatFocused = false;
            });
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function updatePlayer() {
            if (!gameStarted || chatFocused) return;
            
            const speed = (keys['ShiftLeft'] || keys['ShiftRight']) ? 2.0 : 1.0;
            const lookSpeed = 0.03;
            
            // Update survival time and radiation
            const currentTime = Date.now();
            survivalTime = currentTime - gameStartTime;
            radiationLevel += radiationRate;
            
            if (radiationLevel >= maxRadiation) {
                triggerRadiationDeath();
                return;
            }
            
            updateRadiationEffects();
            
            // Controls with radiation interference
            const baseInterference = radiationLevel / 100;
            const randomInterference = Math.random() * baseInterference * 0.3;
            const controlMultiplier = 1 + randomInterference;
            const controlInvert = radiationLevel > 85 && Math.random() < 0.3 ? -1 : 1;
            const movementGlitch = radiationLevel > 70 && Math.random() < 0.1;
            
            // Camera rotation
            if (keys['ArrowLeft']) player.rotationY += lookSpeed * controlMultiplier * controlInvert;
            if (keys['ArrowRight']) player.rotationY -= lookSpeed * controlMultiplier * controlInvert;
            if (keys['ArrowUp']) player.rotationX += lookSpeed * controlMultiplier * controlInvert;
            if (keys['ArrowDown']) player.rotationX -= lookSpeed * controlMultiplier * controlInvert;
            
            // Radiation glitches
            if (radiationLevel > 50) {
                const glitchChance = (radiationLevel - 50) / 50 * 0.08;
                if (Math.random() < glitchChance) {
                    player.rotationX += (Math.random() - 0.5) * 0.2 * baseInterference;
                    player.rotationY += (Math.random() - 0.5) * 0.2 * baseInterference;
                }
            }
            
            player.rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, player.rotationX));
            
            camera.rotation.order = 'YXZ';
            camera.rotation.y = player.rotationY;
            camera.rotation.x = player.rotationX;
            
            // Movement
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);
            const up = new THREE.Vector3(0, 1, 0);
            forward.applyQuaternion(camera.quaternion);
            right.applyQuaternion(camera.quaternion);
            
            const movement = new THREE.Vector3();
            
            if (keys['KeyW']) {
                if (movementGlitch) {
                    movement.addScaledVector(forward, -speed * 0.5);
                } else {
                    movement.addScaledVector(forward, speed);
                }
            }
            if (keys['KeyS']) {
                if (movementGlitch) {
                    movement.addScaledVector(forward, speed * 0.5);
                } else {
                    movement.addScaledVector(forward, -speed);
                }
            }
            if (keys['KeyA']) {
                if (movementGlitch) {
                    movement.addScaledVector(right, speed * 0.5);
                } else {
                    movement.addScaledVector(right, -speed);
                }
            }
            if (keys['KeyD']) {
                if (movementGlitch) {
                    movement.addScaledVector(right, -speed * 0.5);
                } else {
                    movement.addScaledVector(right, speed);
                }
            }
            if (keys['KeyQ']) movement.addScaledVector(up, speed);
            if (keys['KeyE']) movement.addScaledVector(up, -speed);
            
            // Radiation drift
            if (radiationLevel > 60) {
                const drift = baseInterference * 0.1;
                movement.x += (Math.random() - 0.5) * drift;
                movement.y += (Math.random() - 0.5) * drift;
                movement.z += (Math.random() - 0.5) * drift;
            }
            
            player.x += movement.x;
            player.y += movement.y;
            player.z += movement.z;
            
            camera.position.set(player.x, player.y, player.z);
            
            checkInteractions();
            updateHUD();
        }
        
        function updateRadiationEffects() {
            const radiationOverlay = document.getElementById('radiationOverlay');
            const glitchOverlay = document.getElementById('glitchOverlay');
            const staticOverlay = document.getElementById('staticOverlay');
            
            if (radiationLevel > 15) {
                radiationOverlay.classList.add('active');
                radiationOverlay.style.opacity = Math.min(1, (radiationLevel - 15) / 40);
            } else {
                radiationOverlay.classList.remove('active');
            }
            
            if (radiationLevel > 25) {
                glitchOverlay.style.opacity = Math.min(1, (radiationLevel - 25) / 30);
            } else {
                glitchOverlay.style.opacity = 0;
            }
            
            if (radiationLevel > 40) {
                staticOverlay.style.opacity = Math.min(0.8, (radiationLevel - 40) / 25);
            } else {
                staticOverlay.style.opacity = 0;
            }
            
            // Camera shake
            if (radiationLevel > 80 && Math.random() < 0.1) {
                const shake = radiationLevel / 100;
                camera.position.x += (Math.random() - 0.5) * shake * 3;
                camera.position.y += (Math.random() - 0.5) * shake * 3;
                camera.position.z += (Math.random() - 0.5) * shake * 3;
            }
            
            // Jumpscares
            const currentTime = Date.now();
            const timeSinceLastJumpscare = currentTime - lastJumpscareTime;
            const radiationMultiplier = 1 + (radiationLevel / 100) * 8;
            
            if (timeSinceLastJumpscare > (25000 / radiationMultiplier) && Math.random() < 0.02 * radiationMultiplier) {
                triggerJumpscare();
                lastJumpscareTime = currentTime;
            }
        }
        
        function triggerJumpscare() {
            const overlay = document.getElementById('jumpscare');
            
            const effects = [
                'radial-gradient(circle, rgba(255,0,0,0.9) 0%, rgba(255,0,0,0.3) 100%)',
                'repeating-linear-gradient(0deg, #fff 0px, #000 2px, #fff 4px)',
                'linear-gradient(90deg, #00ff00, #004400, #00ff00)',
                'radial-gradient(circle, rgba(255,255,255,0.8) 20%, rgba(0,0,0,0.9) 100%)',
                'linear-gradient(45deg, #ff00ff, #00ffff, #ffff00)'
            ];
            
            overlay.style.background = effects[Math.floor(Math.random() * effects.length)];
            overlay.classList.add('active');
            
            playJumpscareSound();
            
            setTimeout(() => {
                overlay.classList.remove('active');
            }, 200 + Math.random() * 400);
        }
        
        function checkInteractions() {
            const playerPos = new THREE.Vector3(player.x, player.y, player.z);
            
            objects.forEach((obj, index) => {
                const distance = playerPos.distanceTo(obj.position);
                
                // For server-managed objects, send collection request to server
                if (obj.userData.serverManaged) {
                    const collectRadius = getCollectRadius(obj.userData.type);
                    if (distance < collectRadius && !obj.userData.collectionRequested) {
                        obj.userData.collectionRequested = true; // Prevent spam
                        
                        if (socket && socket.connected) {
                            console.log(`🎯 Attempting to collect ${obj.userData.type} (distance: ${Math.round(distance)})`);
                            socket.emit('collect_resource', { objectId: obj.userData.serverId });
                            
                            // Visual feedback for attempt
                            showNotification(`Collecting ${obj.userData.type}...`, 1000);
                        }
                        
                        // Reset request flag after delay
                        setTimeout(() => {
                            if (obj.userData) obj.userData.collectionRequested = false;
                        }, 2000);
                    }
                    return; // Skip local collection logic for server objects
                }
                
                // Local object collection (fallback for offline mode)
                if (obj.userData.type === 'discovery' && !obj.userData.collected && distance < 30) {
                    obj.userData.collected = true;
                    discoveries++;
                    addScore(POINTS.discovery);
                    playSound(440);
                    showNotification(`Discovery Found! +${POINTS.discovery} points`);
                    scene.remove(obj);
                    objects.splice(index, 1);
                }
                
                else if (obj.userData.type === 'exploding' && !obj.userData.exploded && distance < 25) {
                    obj.userData.exploded = true;
                    discoveries++;
                    addScore(POINTS.explosion);
                    explodeObject(obj);
                    playSound(200);
                    showNotification(`Creature Exploded! +${POINTS.explosion} points`);
                    scene.remove(obj);
                    objects.splice(index, 1);
                }
                
                else if (obj.userData.type === 'rare' && !obj.userData.collected && distance < 20) {
                    obj.userData.collected = true;
                    rareItems++;
                    addScore(POINTS.rareEntity);
                    playSound(880);
                    showNotification(`Rare Entity Captured! +${POINTS.rareEntity} points`);
                    scene.remove(obj);
                    objects.splice(index, 1);
                }
                
                else if (obj.userData.type === 'spaceCreature' && !obj.userData.touched && distance < 35) {
                    obj.userData.touched = true;
                    creaturesFound++;
                    addScore(POINTS.spaceCreature);
                    playSound(660);
                    showNotification(`Space Creature Encountered! +${POINTS.spaceCreature} points`);
                    
                    if (obj.children[0] && obj.children[0].material) {
                        obj.children[0].material.emissive.setHex(0x444444);
                        setTimeout(() => {
                            if (obj.children[0] && obj.children[0].material) {
                                obj.children[0].material.emissive.setHex(0x111111);
                            }
                        }, 2000);
                    }
                }
                
                else if (obj.userData.type === 'ringPortal' && !obj.userData.used && distance < 30) {
                    obj.userData.used = true;
                    const reductionAmount = 25 + Math.random() * 15;
                    radiationLevel = Math.max(0, radiationLevel - reductionAmount);
                    
                    addScore(POINTS.portalUsed);
                    playPortalSound();
                    showNotification(`Portal Used! Radiation reduced by ${Math.round(reductionAmount)}% +${POINTS.portalUsed} points`);
                    
                    // 🔧 PORTALS VANISH IMMEDIATELY when used locally
                    scene.remove(obj);
                    const index = objects.indexOf(obj);
                    if (index > -1) objects.splice(index, 1);
                }
                
                // Rare entities flee
                else if (obj.userData.type === 'rare' && !obj.userData.collected && distance < 100) {
                    const fleeDir = new THREE.Vector3()
                        .subVectors(obj.position, playerPos)
                        .normalize()
                        .multiplyScalar(obj.userData.fleeSpeed);
                    obj.position.add(fleeDir);
                }
                
                // Space creatures flee
                else if (obj.userData.type === 'spaceCreature' && distance < obj.userData.detectionRange) {
                    obj.userData.fleeing = true;
                    const fleeDir = new THREE.Vector3()
                        .subVectors(obj.position, playerPos)
                        .normalize()
                        .multiplyScalar(obj.userData.fleeSpeed);
                    obj.position.add(fleeDir);
                } else if (obj.userData.type === 'spaceCreature') {
                    obj.userData.fleeing = false;
                }
            });
        }
        
        function getCollectRadius(objectType) {
            const radii = {
                'discovery': 30,
                'exploding': 25,
                'rare': 20,
                'spaceCreature': 35,
                'ringPortal': 30
            };
            return radii[objectType] || 30;
        }
        
        function explodeObject(obj) {
            const pos = obj.position;
            const hue = obj.userData.hue;
            
            for (let i = 0; i < 8; i++) {
                const shard = new THREE.Mesh(
                    new THREE.TetrahedronGeometry(2),
                    new THREE.MeshLambertMaterial({
                        color: new THREE.Color().setHSL(hue, 0.9, 0.7),
                        transparent: true,
                        opacity: 0.8
                    })
                );
                
                shard.position.copy(pos);
                shard.position.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20
                ));
                
                shard.userData = {
                    type: 'shard',
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 4,
                        Math.random() * 3 + 1,
                        (Math.random() - 0.5) * 4
                    ),
                    life: 1.0
                };
                
                scene.add(shard);
                objects.push(shard);
            }
        }
        
        function animateObjects() {
            const time = Date.now() * 0.001;
            
            objects.forEach((obj, index) => {
                if (obj.userData.type === 'exploding') {
                    obj.position.y = obj.userData.originalY + Math.sin(time * 2) * 8;
                    obj.rotation.x += obj.userData.rotSpeed;
                    obj.rotation.y += obj.userData.rotSpeed * 0.7;
                }
                
                else if (obj.userData.type === 'rare') {
                    obj.position.y = obj.userData.originalY + Math.sin(time * 1.5) * 5;
                    obj.rotation.y += 0.02;
                }
                
                else if (obj.userData.type === 'discovery') {
                    obj.rotation.y += 0.01;
                }
                
                else if (obj.userData.type === 'spaceCreature') {
                    obj.position.y = obj.userData.originalY + Math.sin(time * obj.userData.swimSpeed) * 10;
                    
                    if (obj.userData.fleeing) {
                        // 🔧 PANIC ANIMATION - Fast wobbling tentacles when fleeing
                        obj.rotation.y += 0.15 * Math.sin(time * 10); // More erratic rotation
                        obj.rotation.x += 0.08 * Math.cos(time * 8);
                        
                        // Very fast tentacle movement - panic wobbling!
                        for (let i = 1; i <= obj.userData.tentacleCount; i++) {
                            if (obj.children[i]) {
                                obj.children[i].rotation.x = Math.sin(time * 12 + i) * 1.2; // Faster and more extreme
                                obj.children[i].rotation.z = Math.cos(time * 10 + i) * 0.9;
                                // Add some random jitter to make it look panicked
                                obj.children[i].rotation.y = Math.sin(time * 15 + i * 2) * 0.4;
                            }
                        }
                        
                        // Body also wobbles when panicking
                        if (obj.children[0]) {
                            obj.children[0].rotation.x = Math.sin(time * 8) * 0.2;
                            obj.children[0].rotation.z = Math.cos(time * 6) * 0.15;
                        }
                    } else {
                        // Normal calm animation
                        obj.rotation.y += 0.005;
                        
                        // Gentle tentacle movement when calm
                        for (let i = 1; i <= obj.userData.tentacleCount; i++) {
                            if (obj.children[i]) {
                                obj.children[i].rotation.x = Math.sin(time * 3 + i) * 0.3;
                                obj.children[i].rotation.z = Math.cos(time * 2 + i) * 0.2;
                            }
                        }
                    }
                }
                
                else if (obj.userData.type === 'ringPortal') {
                    obj.rotation.y += 0.01;
                    if (obj.children[1]) {
                        obj.children[1].rotation.y -= 0.015;
                    }
                }
                
                else if (obj.userData.type === 'shard') {
                    obj.position.add(obj.userData.velocity);
                    obj.userData.velocity.y -= 0.05;
                    obj.userData.velocity.multiplyScalar(0.98);
                    
                    obj.userData.life -= 0.01;
                    obj.material.opacity = obj.userData.life;
                    
                    if (obj.userData.life <= 0) {
                        scene.remove(obj);
                        objects.splice(index, 1);
                    }
                }
            });
        }
        
        function playSound(frequency) {
            if (!audioContext) return;
            try {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.frequency.setValueAtTime(frequency, audioContext.currentTime);
                osc.type = 'triangle';
                
                gain.gain.setValueAtTime(0, audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);
                
                osc.connect(gain);
                gain.connect(masterGain);
                
                osc.start();
                osc.stop(audioContext.currentTime + 1);
            } catch (e) {
                console.warn('Audio error:', e);
            }
        }
        
        function playPortalSound() {
            if (!audioContext) return;
            try {
                const frequencies = [330, 440, 550, 660];
                frequencies.forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        
                        osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                        osc.type = 'sine';
                        
                        gain.gain.setValueAtTime(0, audioContext.currentTime);
                        gain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.5);
                        
                        osc.connect(gain);
                        gain.connect(masterGain);
                        
                        osc.start();
                        osc.stop(audioContext.currentTime + 1.5);
                    }, i * 100);
                });
            } catch (e) {
                console.warn('Portal sound error:', e);
            }
        }
        
        function playJumpscareSound() {
            if (!audioContext) return;
            try {
                const baseFreq = 40 + Math.random() * 200;
                const frequencies = [baseFreq, baseFreq * 1.5, baseFreq * 2.3];
                
                frequencies.forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        
                        osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                        osc.type = 'sawtooth';
                        
                        gain.gain.setValueAtTime(0, audioContext.currentTime);
                        gain.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.01);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                        
                        osc.connect(gain);
                        gain.connect(masterGain);
                        
                        osc.start();
                        osc.stop(audioContext.currentTime + 0.4);
                    }, i * 15);
                });
            } catch (e) {
                console.warn('Jumpscare sound error:', e);
            }
        }
        
        function playDeathSound() {
            if (!audioContext) return;
            try {
                // Dramatic death sound with multiple layers
                const frequencies = [30, 60, 120, 240, 480];
                
                frequencies.forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        const filter = audioContext.createBiquadFilter();
                        
                        osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                        osc.type = 'sawtooth';
                        
                        filter.type = 'lowpass';
                        filter.frequency.setValueAtTime(freq * 1.5, audioContext.currentTime);
                        filter.Q.setValueAtTime(10, audioContext.currentTime);
                        
                        gain.gain.setValueAtTime(0, audioContext.currentTime);
                        gain.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 3);
                        
                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(masterGain);
                        
                        osc.start();
                        osc.stop(audioContext.currentTime + 3);
                    }, i * 200);
                });
                
                // Add dramatic noise burst
                const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 2, audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < output.length; i++) {
                    output[i] = (Math.random() * 2 - 1) * 0.2 * Math.exp(-i / (audioContext.sampleRate * 0.5));
                }
                
                const noiseSource = audioContext.createBufferSource();
                const noiseGain = audioContext.createGain();
                noiseSource.buffer = noiseBuffer;
                noiseGain.gain.setValueAtTime(0.25, audioContext.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 2);
                
                noiseSource.connect(noiseGain);
                noiseGain.connect(masterGain);
                noiseSource.start();
                
            } catch (e) {
                console.warn('Death sound error:', e);
            }
        }
        
        function startMusic() {
            if (!audioContext || musicPlaying) return;
            musicPlaying = true;
            
            const notes = [65.41, 82.41, 98.00, 130.81, 164.81];
            
            notes.forEach((freq, i) => {
                setTimeout(() => {
                    if (!musicPlaying || !audioContext) return;
                    
                    try {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        
                        osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                        osc.type = 'sine';
                        
                        gain.gain.setValueAtTime(0, audioContext.currentTime);
                        gain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 2);
                        
                        osc.connect(gain);
                        gain.connect(masterGain);
                        
                        osc.start();
                        ambientOscillators.push(osc);
                    } catch (e) {
                        console.warn('Music error:', e);
                    }
                }, i * 2000);
            });
        }
        
        function toggleMusic() {
            if (musicPlaying) {
                ambientOscillators.forEach(osc => {
                    try { osc.stop(); } catch (e) {}
                });
                ambientOscillators = [];
                musicPlaying = false;
                showNotification('Music Off');
            } else {
                startMusic();
                showNotification('Music On');
            }
        }
        
        function updateHUD() {
            document.getElementById('coords').textContent = 
                `${Math.round(player.x)}, ${Math.round(player.y)}, ${Math.round(player.z)}`;
            
            // Always calculate and show local score for immediate feedback
            const currentSurvivalScore = Math.floor(survivalTime / 1000) * POINTS.survivalBonus;
            const currentScore = discoveries * POINTS.discovery + 
                               rareItems * POINTS.rareEntity + 
                               creaturesFound * POINTS.spaceCreature + 
                               currentSurvivalScore;
            
            document.getElementById('score').textContent = currentScore;
            document.getElementById('discoveries').textContent = discoveries;
            document.getElementById('rare').textContent = rareItems;
            document.getElementById('creatures').textContent = creaturesFound;
            document.getElementById('radiation').textContent = Math.round(radiationLevel);
            
            // Update radiation color
            const radiationElement = document.getElementById('radiation');
            if (radiationLevel < 30) {
                radiationElement.style.color = '#4ecdc4';
                radiationElement.style.textShadow = 'none';
            } else if (radiationLevel < 60) {
                radiationElement.style.color = '#ffd93d';
                radiationElement.style.textShadow = 'none';
            } else if (radiationLevel < 85) {
                radiationElement.style.color = '#ff6b6b';
                radiationElement.style.textShadow = 'none';
            } else {
                radiationElement.style.color = '#ff0000';
                radiationElement.style.textShadow = '0 0 10px #ff0000';
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            updatePlayer();
            animateObjects();
            
            // Simple animation for other players
            const time = Date.now() * 0.001;
            for (const [id, playerObj] of otherPlayers) {
                if (playerObj.mesh) {
                    playerObj.mesh.position.y = playerObj.data.y + Math.sin(time * 2) * 0.5;
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // Initialize everything
        console.log('🎯 Initializing game...');
        init();
    </script>
</body>
</html>
