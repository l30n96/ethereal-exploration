function updatePlayerDots(players) {
            console.log('üì° Updating radar with players:', players);
            playerDots = players.map(p => ({
                x: p.x,
                y: p.y,
                z: p.z,
                color: p.isAlive ? p.color : 0xff0000,
                name: p.name,
                distance: p.distance,
                isAlive: p.isAlive,
                speedMultiplier: p.currentSpeedMultiplier || 1.0
            }));
            updateRadar();
        }
        
        function updatePlayerCount(count) {
            document.getElementById('playerCount').textContent = count;
        }
        
        function updatePlayerList(players) {
            const playerList = document.getElementById('playerList');
            let html = '<div style="font-weight: bold; margin-bottom: 5px;">Other Players</div>';
            
            if (!players || players.length === 0) {
                html += '<div style="opacity: 0.7; font-size: 11px;">No other players nearby</div>';
            } else {
                console.log('üìù Updating player list with', players.length, 'players');
                players.forEach(p => {
                    const colorHex = p.color ? p.color.toString(16).padStart(6, '0') : 'ffffff';
                    const statusClass = p.isAlive ? '' : 'dead';
                    const speedIcon = p.currentSpeedMultiplier > 1.2 ? '‚ö°' : '';
                    const statusIcon = p.isAlive ? '' : 'üíÄ';
                    
                    html += `
                        <div class="player-entry ${statusClass}">
                            <span style="color: #${colorHex}">${p.name || 'Unknown'}${statusIcon}${speedIcon}</span>
                            <span>${p.distance || '?'}m | ${p.score || 0}pts</span>
                        </div>
                    `;
                });
            }
            playerList.innerHTML = html;
        }
        
        function updateRadar() {
            const radar = document.getElementById('radar');
            if (!radar) return;
            
            // Clear existing dots
            radar.querySelectorAll('.radar-dot').forEach(dot => dot.remove());
            
            const radarRadius = 60; // Radius of the radar display
            const maxDistance = 1000; // Maximum distance to show on radar
            
            console.log('üéØ Updating radar with', playerDots.length, 'player dots');
            
            playerDots.forEach(dot => {
                const dx = dot.x - player.x;
                const dy = dot.y - player.y;
                const dz = dot.z - player.z;
                const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                if (distance > 0 && distance < maxDistance) {
                    // Calculate angle from player's perspective
                    const angle = Math.atan2(dz, dx);
                    const normalizedDistance = Math.min(distance / maxDistance, 1);
                    
                    // Calculate position on radar circle
                    const radarX = Math.cos(angle) * normalizedDistance * radarRadius + radarRadius;
                    const radarY = Math.sin(angle) * normalizedDistance * radarRadius + radarRadius;
                    
                    // Create dot element with enhanced styling
                    const dotElement = document.createElement('div');
                    dotElement.className = 'radar-dot';
                    dotElement.style.left = radarX + 'px';
                    dotElement.style.top = radarY + 'px';
                    dotElement.style.backgroundColor = `#${dot.color.toString(16).padStart(6, '0')}`;
                    dotElement.style.boxShadow = `0 0 4px #${dot.color.toString(16).padStart(6, '0')}`;
                    
                    // Enhanced size based on player status
                    if (!dot.isAlive) {
                        dotElement.style.opacity = '0.5';
                        dotElement.style.animation = 'pulse 1s infinite';
                    } else if (dot.speedMultiplier > 1.2) {
                        dotElement.style.width = '6px';
                        dotElement.style.height = '6px';
                        dotElement.style.animation = 'speedPulse 0.5s infinite';
                    }
                    
                    dotElement.title = `${dot.name} (${Math.round(distance)}m)${!dot.isAlive ? ' üíÄ' : ''}${dot.speedMultiplier > 1.2 ? ' ‚ö°' : ''}`;
                    
                    radar.appendChild(dotElement);
                    console.log(`üìç Added radar dot for ${dot.name} at distance ${Math.round(distance)}m`);
                }
            });
        }
        
        function updateLeaderboard(leaderboard, battleStats) {
            const mini = document.getElementById('leaderboardMini');
            if (!leaderboard || leaderboard.length === 0) {
                mini.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px; color: #ffd700;">üëë Top Players</div><div>No data yet</div>';
                return;
            }
            
            let html = '<div style="font-weight: bold; margin-bottom: 5px; color: #ffd700;">üëë Top Players</div>';
            
            leaderboard.slice(0, 5).forEach((player, index) => {
                const rankIcon = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                const aliveIcon = player.isAlive ? '' : 'üíÄ';
                const speedIcon = player.currentSpeedMultiplier > 120 ? '‚ö°' : '';
                
                html += `
                    <div style="font-size: 10px; margin: 2px 0; ${player.name === playerName ? 'color: #4ecdc4; font-weight: bold;' : ''}">
                        ${rankIcon} ${player.name}${aliveIcon}${speedIcon}<br>
                        <span style="opacity: 0.8;">${player.score}pts | ${player.killCount}K/${player.deathCount}D</span>
                    </div>
                `;
            });
            
            if (battleStats) {
                html += `<div style="margin-top: 5px; font-size: 9px; opacity: 0.7;">
                    Battles: ${battleStats.activeBattles} | Deaths: ${battleStats.totalDeaths}
                </div>`;
            }
            
            mini.innerHTML = html;
        }
        
        function addChatMessage(playerName, message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageElement = document.createElement('div');
            
            const timestamp = new Date().toLocaleTimeString('en-US', { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            // Enhanced voice indicator for TTS-enabled messages
            const voiceIndicator = (chatTTSEnabled && playerName !== 'System' && playerName !== 'You') ? 'üé§ ' : '';
            
            messageElement.innerHTML = `<span style="color: #666; font-size: 10px;">[${timestamp}]</span> ${voiceIndicator}<strong style="color: #4ecdc4">${playerName}:</strong> ${message}`;
            messageElement.style.marginBottom = '3px';
            messageElement.style.wordWrap = 'break-word';
            
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            while (chatMessages.children.length > 50) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
        }
        
        function showNotification(text, duration = 3000) {
            const notif = document.getElementById('notification');
            document.getElementById('notifText').textContent = text;
            notif.classList.add('show');
            setTimeout(() => notif.classList.remove('show'), duration);
        }
        
        function updateSpeedMultiplier() {
            const now = Date.now();
            
            // Check if boost is still active
            if (now > speedBoostEndTime) {
                // Calculate base speed with score bonus
                const scoreBonus = Math.min(
                    score * PVP_SETTINGS.scoreSpeedBonus,
                    PVP_SETTINGS.maxScoreSpeed - PVP_SETTINGS.baseSpeed
                );
                currentSpeedMultiplier = PVP_SETTINGS.baseSpeed + scoreBonus;
            } else {
                // Still in boost mode
                currentSpeedMultiplier = PVP_SETTINGS.boostSpeed;
            }
        }
        
        function checkInteractions() {
            if (!isAlive) return; // Dead players can't interact
            
            const playerPos = new THREE.Vector3(player.x, player.y, player.z);
            
            objects.forEach((obj, index) => {
                const distance = playerPos.distanceTo(obj.position);
                
                // For server-managed objects, send collection request to server
                if (obj.userData.serverId) {
                    const collectRadius = getCollectRadius(obj.userData.type);
                    if (distance < collectRadius && !obj.userData.collectionRequested) {
                        obj.userData.collectionRequested = true; // Prevent spam
                        
                        if (socket && socket.connected) {
                            console.log(`üéØ Attempting to collect ${obj.userData.type} (distance: ${Math.round(distance)})`);
                            socket.emit('collect_resource', { objectId: obj.userData.serverId });
                            
                            // Visual feedback for attempt
                            showNotification(`Collecting ${obj.userData.type}...`, 1000);
                        }
                        
                        // Reset request flag after delay
                        setTimeout(() => {
                            if (obj.userData) obj.userData.collectionRequested = false;
                        }, 2000);
                    }
                    return; // Skip local collection logic for server objects
                }
                
                // Local object collection (fallback for offline mode)
                if (obj.userData.type === 'discovery' && !obj.userData.collected && distance < 30) {
                    obj.userData.collected = true;
                    discoveries++;
                    score += 10;
                    playSound(440);
                    showNotification(`Discovery Found! +10 points`);
                    scene.remove(obj);
                    objects.splice(index, 1);
                }
                
                else if (obj.userData.type === 'exploding' && !obj.userData.exploded && distance < 25) {
                    obj.userData.exploded = true;
                    discoveries++;
                    score += 15;
                    explodeObject(obj);
                    playSound(200);
                    showNotification(`Creature Exploded! +15 points`);
                    scene.remove(obj);
                    objects.splice(index, 1);
                }
                
                else if (obj.userData.type === 'rare' && !obj.userData.collected && distance < 20) {
                    obj.userData.collected = true;
                    rareItems++;
                    score += 50;
                    playSound(880);
                    showNotification(`Rare Entity Captured! +50 points`);
                    scene.remove(obj);
                    objects.splice(index, 1);
                }
                
                else if (obj.userData.type === 'spaceCreature' && !obj.userData.touched && distance < 35) {
                    obj.userData.touched = true;
                    creaturesFound++;
                    score += 25;
                    playSound(660);
                    showNotification(`Space Creature Encountered! +25 points`);
                    
                    if (obj.children[0] && obj.children[0].material) {
                        obj.children[0].material.emissive.setHex(0x444444);
                        setTimeout(() => {
                            if (obj.children[0] && obj.children[0].material) {
                                obj.children[0].material.emissive.setHex(0x111111);
                            }
                        }, 2000);
                    }
                }
                
                else if (obj.userData.type === 'ringPortal' && !obj.userData.used && distance < 30) {
                    obj.userData.used = true;
                    const reductionAmount = 25 + Math.random() * 15;
                    radiationLevel = Math.max(0, radiationLevel - reductionAmount);
                    
                    score += 5;
                    playPortalSound();
                    showNotification(`Portal Used! Radiation reduced by ${Math.round(reductionAmount)}%`);
                    
                    scene.remove(obj);
                    const index = objects.indexOf(obj);
                    if (index > -1) objects.splice(index, 1);
                }
                
                // Enhanced creature behavior with server sync
                else if (obj.userData.type === 'rare' && !obj.userData.collected && distance < 100) {
                    const fleeDir = new THREE.Vector3()
                        .subVectors(obj.position, playerPos)
                        .normalize()
                        .multiplyScalar(obj.userData.fleeSpeed);
                    obj.position.add(fleeDir);
                }
                
                else if (obj.userData.type === 'spaceCreature' && distance < obj.userData.detectionRange) {
                    obj.userData.fleeing = true;
                    const fleeDir = new THREE.Vector3()
                        .subVectors(obj.position, playerPos)
                        .normalize()
                        .multiplyScalar(obj.userData.fleeSpeed);
                    obj.position.add(fleeDir);
                    
                    // Send trajectory update to server for multiplayer sync
                    if (socket && socket.connected && obj.userData.serverId) {
                        socket.emit('creature_trajectory', {
                            objectId: obj.userData.serverId,
                            startPosition: obj.position,
                            fleeDirection: fleeDir.normalize(),
                            fleeSpeed: obj.userData.fleeSpeed,
                            timestamp: Date.now(),
                            fleeing: true
                        });
                    }
                } else if (obj.userData.type === 'spaceCreature') {
                    obj.userData.fleeing = false;
                }
            });
        }
        
        function getCollectRadius(objectType) {
            const radii = {
                'discovery': 30,
                'exploding': 25,
                'rare': 20,
                'spaceCreature': 35,
                'ringPortal': 30
            };
            return radii[objectType] || 30;
        }
        
        function updateRadiationEffects() {
            const radiationOverlay = document.getElementById('radiationOverlay');
            const glitchOverlay = document.getElementById('glitchOverlay');
            
            if (radiationLevel > 15) {
                radiationOverlay.classList.add('active');
                radiationOverlay.style.opacity = Math.min(1, (radiationLevel - 15) / 40);
            } else {
                radiationOverlay.classList.remove('active');
            }
            
            if (radiationLevel > 25) {
                glitchOverlay.style.opacity = Math.min(1, (radiationLevel - 25) / 30);
            } else {
                glitchOverlay.style.opacity = 0;
            }
            
            // Enhanced camera shake for high radiation
            if (radiationLevel > 80 && Math.random() < 0.1) {
                const shake = radiationLevel / 100;
                camera.position.x += (Math.random() - 0.5) * shake * 3;
                camera.position.y += (Math.random() - 0.5) * shake * 3;
                camera.position.z += (Math.random() - 0.5) * shake * 3;
            }
        }
        
        function updatePlayer() {
            if (!gameStarted || chatFocused || !isAlive) return;
            
            updateSpeedMultiplier();
            
            const lookSpeed = 0.05;
            const speed = currentSpeedMultiplier * (keys['ShiftLeft'] || keys['ShiftRight'] ? 2.0 : 1.0);
            
            // Enhanced controls with radiation interference
            const baseInterference = radiationLevel / 100;
            const randomInterference = Math.random() * baseInterference * 0.3;
            const controlMultiplier = 1 + randomInterference;
            const controlInvert = radiationLevel > 85 && Math.random() < 0.3 ? -1 : 1;
            const movementGlitch = radiationLevel > 70 && Math.random() < 0.1;
            
            // Camera rotation
            if (keys['ArrowLeft']) player.rotationY += lookSpeed * controlMultiplier * controlInvert;
            if (keys['ArrowRight']) player.rotationY -= lookSpeed * controlMultiplier * controlInvert;
            if (keys['ArrowUp']) player.rotationX += lookSpeed * controlMultiplier * controlInvert;
            if (keys['ArrowDown']) player.rotationX -= lookSpeed * controlMultiplier * controlInvert;
            
            // Radiation glitches
            if (radiationLevel > 50) {
                const glitchChance = (radiationLevel - 50) / 50 * 0.08;
                if (Math.random() < glitchChance) {
                    player.rotationX += (Math.random() - 0.5) * 0.2 * baseInterference;
                    player.rotationY += (Math.random() - 0.5) * 0.2 * baseInterference;
                }
            }
            
            player.rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, player.rotationX));
            
            camera.rotation.order = 'YXZ';
            camera.rotation.y = player.rotationY;
            camera.rotation.x = player.rotationX;
            
            // Movement with enhanced speed system
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);
            const up = new THREE.Vector3(0, 1, 0);
            forward.applyQuaternion(camera.quaternion);
            right.applyQuaternion(camera.quaternion);
            
            const movement = new THREE.Vector3();
            
            if (keys['KeyW']) {
                if (movementGlitch) {
                    movement.addScaledVector(forward, -speed * 0.5);
                } else {
                    movement.addScaledVector(forward, speed);
                }
            }
            if (keys['KeyS']) {
                if (movementGlitch) {
                    movement.addScaledVector(forward, speed * 0.5);
                } else {
                    movement.addScaledVector(forward, -speed);
                }
            }
            if (keys['KeyA']) {
                if (movementGlitch) {
                    movement.addScaledVector(right, speed * 0.5);
                } else {
                    movement.addScaledVector(right, -speed);
                }
            }
            if (keys['KeyD']) {
                if (movementGlitch) {
                    movement.addScaledVector(right, -speed * 0.5);
                } else {
                    movement.addScaledVector(right, speed);
                }
            }
            if (keys['KeyQ']) movement.addScaledVector(up, speed);
            if (keys['KeyE']) movement.addScaledVector(up, -speed);
            
            // Radiation drift
            if (radiationLevel > 60) {
                const drift = baseInterference * 0.1;
                movement.x += (Math.random() - 0.5) * drift;
                movement.y += (Math.random() - 0.5) * drift;
                movement.z += (Math.random() - 0.5) * drift;
            }
            
            player.x += movement.x;
            player.y += movement.y;
            player.z += movement.z;
            
            camera.position.set(player.x, player.y, player.z);
            
            checkInteractions();
            updateHUD();
        }
        
        function updateHUD() {
            document.getElementById('coords').textContent = 
                `${Math.round(player.x)}, ${Math.round(player.y)}, ${Math.round(player.z)}`;
            
            updateLocalStats();
            updateSpeedDisplay();
        }
        
        // Enhanced sound functions
        function playSound(frequency) {
            if (!audioContext) return;
            try {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.frequency.setValueAtTime(frequency, audioContext.currentTime);
                osc.type = 'triangle';
                
                gain.gain.setValueAtTime(0, audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);
                
                osc.connect(gain);
                gain.connect(masterGain);
                
                osc.start();
                osc.stop(audioContext.currentTime + 1);
            } catch (e) {
                console.warn('Audio error:', e);
            }
        }
        
        function playProximityWarningSound() {
            if (!audioContext || proximityWarningSound) return;
            
            try {
                proximityWarningSound = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                proximityWarningSound.frequency.setValueAtTime(220, audioContext.currentTime);
                proximityWarningSound.type = 'square';
                
                gain.gain.setValueAtTime(0, audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.1);
                
                // Pulsing effect
                setInterval(() => {
                    if (proximityWarningSound && isInProximityBattle) {
                        gain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.2);
                        gain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.4);
                    }
                }, 400);
                
                proximityWarningSound.connect(gain);
                gain.connect(masterGain);
                proximityWarningSound.start();
            } catch (e) {
                console.warn('Proximity warning sound error:', e);
            }
        }
        
        function playRadiationWarningSound() {
            playSound(100 + radiationLevel * 5);
        }
        
        function playPortalSound() {
            if (!audioContext) return;
            try {
                const frequencies = [330, 440, 550, 660];
                frequencies.forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        
                        osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                        osc.type = 'sine';
                        
                        gain.gain.setValueAtTime(0, audioContext.currentTime);
                        gain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.5);
                        
                        osc.connect(gain);
                        gain.connect(masterGain);
                        
                        osc.start();
                        osc.stop(audioContext.currentTime + 1.5);
                    }, i * 100);
                });
            } catch (e) {
                console.warn('Portal sound error:', e);
            }
        }
        
        function playDeathSound() {
            if (!audioContext) return;
            try {
                // Enhanced dramatic death sound
                const frequencies = [30, 60, 120, 240, 480];
                
                frequencies.forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        const filter = audioContext.createBiquadFilter();
                        
                        osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                        osc.type = 'sawtooth';
                        
                        filter.type = 'lowpass';
                        filter.frequency.setValueAtTime(freq * 1.5, audioContext.currentTime);
                        filter.Q.setValueAtTime(10, audioContext.currentTime);
                        
                        gain.gain.setValueAtTime(0, audioContext.currentTime);
                        gain.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 3);
                        
                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(masterGain);
                        
                        osc.start();
                        osc.stop(audioContext.currentTime + 3);
                    }, i * 200);
                });
            } catch (e) {
                console.warn('Death sound error:', e);
            }
        }
        
        // TTS function for chat
        function speakChatMessage(playerName, message) {
            if (!chatTTSEnabled || !speechSynthesis) return;
            
            try {
                const utterance = new SpeechSynthesisUtterance(`${playerName} says: ${message}`);
                utterance.volume = 0.3;
                utterance.rate = 1.2;
                utterance.pitch = 0.8 + Math.random() * 0.4; // Random pitch for different players
                
                if (availableVoices.length > 0) {
                    utterance.voice = availableVoices[Math.floor(Math.random() * availableVoices.length)];
                }
                
                speechSynthesis.speak(utterance);
            } catch (e) {
                console.warn('TTS error:', e);
            }
        }
        
        function toggleChatTTS() {
            chatTTSEnabled = !chatTTSEnabled;
            showNotification(`Voice Chat: ${chatTTSEnabled ? 'ON' : 'OFF'}`, 2000);
            
            if (chatTTSEnabled && speechSynthesis) {
                availableVoices = speechSynthesis.getVoices();
                console.log('üé§ Available voices:', availableVoices.length);
            }
        }
        
        // Enhanced control setup
        function setupControls() {
            document.addEventListener('keydown', (e) => {
                if (chatFocused && e.code !== 'Enter' && e.code !== 'Escape') return;
                
                keys[e.code] = true;
                
                if (e.code === 'KeyR' && isAlive) {
                    player.x = 0;
                    player.y = 0;
                    player.z = 0;
                    player.rotationX = 0;
                    player.rotationY = 0;
                    camera.position.set(0, 0, 0);
                    camera.rotation.set(0, 0, 0);
                }
                
                if (e.code === 'KeyM') toggleMusic();
                if (e.code === 'KeyV') toggleChatTTS();
                
                if (e.code === 'Enter') {
                    const chatInput = document.getElementById('chatInput');
                    if (!chatFocused) {
                        chatInput.focus();
                        chatFocused = true;
                        e.preventDefault();
                    } else {
                        const message = chatInput.value.trim();
                        if (message) {
                            if (socket && socket.connected) {
                                console.log('üì§ Sending enhanced chat message:', message);
                                socket.emit('chat_message', { message });
                            } else {
                                addChatMessage('You', message);
                                addChatMessage('System', 'Not connected to server');
                            }
                            chatInput.value = '';
                        }
                        chatInput.blur();
                        chatFocused = false;
                        e.preventDefault();
                    }
                }
                
                if (e.code === 'Escape' && chatFocused) {
                    const chatInput = document.getElementById('chatInput');
                    chatInput.value = '';
                    chatInput.blur();
                    chatFocused = false;
                    e.preventDefault();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });
            
            document.getElementById('chatInput').addEventListener('focus', () => {
                chatFocused = true;
            });
            
            document.getElementById('chatInput').addEventListener('blur', () => {
                chatFocused = false;
            });
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        // Initialize everything (same as before but with enhanced logging)
        function init() {
            console.log('üé® Initializing enhanced 3D scene...');
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
            
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,
                alpha: false
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000510, 1);
            
            canvas.style.width = '100vw';
            canvas.style.height = '100vh';
            canvas.style.position = 'fixed';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.zIndex = '1';
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Audio context
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.connect(audioContext.destination);
                masterGain.gain.setValueAtTime(0.3, audioContext.currentTime);
                console.log('üîä Audio system initialized');
            } catch (e) {
                console.warn('<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ethereal Exploration - Enhanced PvP</title>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box;
        }
        
        html, body { 
            width: 100%; 
            height: 100%; 
            overflow: hidden; 
            background: #000; 
            font-family: Arial, sans-serif; 
        }
        
        #gameCanvas { 
            display: block; 
            width: 100vw !important;
            height: 100vh !important;
            position: fixed;
            top: 0;
            left: 0;
        }
        
        .ui-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 100; color: white;
        }
        
        .hud {
            position: absolute; top: 20px; left: 20px;
            font-size: 14px; text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        
        .connection-status {
            position: absolute; top: 20px; left: 50%;
            transform: translateX(-50%); padding: 5px 10px;
            background: rgba(0,0,0,0.7); border-radius: 15px;
            font-size: 12px;
        }
        
        .connected { color: #4ecdc4; }
        .connecting { color: #ffd93d; }
        .disconnected { color: #ff6b6b; }
        .dead { color: #ff0000; animation: pulse 1s infinite; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .chat-container {
            position: absolute; bottom: 20px; left: 20px;
            width: 350px; pointer-events: all;
        }
        
        .chat-messages {
            background: rgba(0,0,0,0.8); border-radius: 10px;
            padding: 10px; max-height: 150px; overflow-y: auto;
            margin-bottom: 10px; font-size: 12px;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }
        
        .chat-input {
            width: 100%; padding: 8px; border: none; border-radius: 5px;
            background: rgba(0,0,0,0.8); color: white;
            border: 1px solid rgba(78, 205, 196, 0.5);
            font-size: 12px;
        }
        
        .chat-input:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.3);
        }
        
        .chat-input::placeholder { color: rgba(255,255,255,0.5); }
        
        .player-list {
            position: absolute; top: 20px; right: 20px;
            max-width: 250px; font-size: 12px;
            background: rgba(0,0,0,0.7); padding: 10px; border-radius: 10px;
            max-height: 300px; overflow-y: auto;
        }
        
        .player-entry {
            padding: 3px 0; display: flex; justify-content: space-between;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .player-entry.dead {
            opacity: 0.5;
            color: #ff6b6b;
        }
        
        .controls {
            position: absolute; bottom: 20px; right: 20px;
            text-align: right; font-size: 12px; opacity: 0.7;
        }
        
        .start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 200;
            pointer-events: all;
        }
        
        .game-title {
            font-size: 4em; margin-bottom: 20px; text-align: center;
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        
        .start-button {
            padding: 15px 40px; font-size: 1.5em;
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border: none; color: white; border-radius: 30px; cursor: pointer;
            transition: all 0.3s ease; margin-top: 30px;
        }
        
        .start-button:hover { transform: scale(1.1); }
        
        .notification {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(78, 205, 196, 0.2); border: 2px solid rgba(78, 205, 196, 0.8);
            border-radius: 15px; padding: 20px; text-align: center;
            opacity: 0; transition: opacity 0.5s ease; z-index: 150;
        }
        
        .notification.show { opacity: 1; }
        
        /* PvP-specific UI elements */
        .proximity-countdown {
            position: absolute; top: 30%; left: 50%; transform: translateX(-50%);
            background: radial-gradient(circle, rgba(255,0,0,0.8) 0%, rgba(100,0,0,0.9) 100%);
            border: 3px solid #ff0000; border-radius: 20px; padding: 30px;
            text-align: center; z-index: 160; display: none;
            animation: proximityPulse 1s infinite;
        }
        
        @keyframes proximityPulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); box-shadow: 0 0 30px #ff0000; }
        }
        
        .proximity-timer {
            font-size: 4em; color: #ffffff; margin-bottom: 10px;
            text-shadow: 0 0 20px #ff0000; font-weight: bold;
        }
        
        .proximity-text {
            font-size: 1.2em; color: #ffcccc; margin-bottom: 5px;
        }
        
        .speed-boost-indicator {
            position: absolute; top: 120px; left: 20px;
            background: rgba(0,255,0,0.2); border: 2px solid #00ff00;
            border-radius: 10px; padding: 10px; display: none;
            animation: speedPulse 0.5s infinite;
        }
        
        @keyframes speedPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); box-shadow: 0 0 20px #00ff00; }
        }
        
        .speed-boost-timer {
            font-size: 1.5em; color: #00ff00; font-weight: bold;
        }
        
        .speed-boost-text {
            font-size: 0.9em; color: #ccffcc;
        }
        
        .player-indicators {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 90;
        }
        
        .player-direction-arrow {
            position: absolute; 
            width: 0; height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 25px solid;
            transform-origin: center bottom;
        }
        
        .death-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(255,0,0,0.9) 0%, rgba(0,0,0,1) 100%);
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 250; pointer-events: all; color: white;
            animation: deathPulse 2s infinite;
        }
        
        @keyframes deathPulse {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; filter: contrast(150%) brightness(120%); }
        }
        
        .death-title {
            font-size: 5em; margin-bottom: 20px; text-align: center;
            color: #ff0000; text-shadow: 0 0 30px #ff0000;
            animation: glitch 0.5s infinite;
        }
        
        @keyframes glitch {
            0% { transform: translate(0); }
            10% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
            20% { transform: translate(2px, -2px); filter: hue-rotate(180deg); }
            30% { transform: translate(-2px, -2px); filter: invert(1); }
            40% { transform: translate(2px, 2px); filter: hue-rotate(270deg); }
            50% { transform: translate(0); filter: contrast(200%); }
        }
        
        .respawn-countdown {
            font-size: 2em; color: #ff6b6b; margin: 20px 0;
        }
        
        .radiation-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 140;
            background: radial-gradient(circle, transparent 40%, rgba(255,100,100,0.3) 100%);
            opacity: 0; transition: opacity 0.3s ease;
        }
        
        .radiation-overlay.active { opacity: 1; }
        
        .glitch-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 130;
            background: repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(255,255,255,0.1) 1px, rgba(255,255,255,0.1) 3px);
            opacity: 0; animation: glitchFlicker 0.05s infinite;
            mix-blend-mode: difference;
        }
        
        @keyframes glitchFlicker {
            0% { opacity: 0; transform: translateX(0); }
            10% { opacity: 1; transform: translateX(-5px); filter: hue-rotate(90deg); }
            20% { opacity: 0; transform: translateX(3px); }
            30% { opacity: 1; transform: translateX(-2px); filter: invert(1); }
            40% { opacity: 0; transform: translateX(4px); }
            50% { opacity: 1; transform: translateX(-6px); filter: contrast(200%); }
            60% { opacity: 0; transform: translateX(2px); }
            70% { opacity: 1; transform: translateX(-3px); filter: saturate(300%); }
            80% { opacity: 0; transform: translateX(5px); }
            90% { opacity: 1; transform: translateX(-4px); filter: brightness(300%); }
            100% { opacity: 0; transform: translateX(0); }
        }
        
        .radar {
            position: absolute; bottom: 180px; right: 20px;
            width: 120px; height: 120px; border-radius: 50%;
            background: rgba(0,0,0,0.8); border: 2px solid #4ecdc4;
            pointer-events: none;
        }
        
        .radar-dot {
            position: absolute; width: 4px; height: 4px;
            border-radius: 50%; transform: translate(-50%, -50%);
        }
        
        .pvp-stats {
            position: absolute; top: 120px; right: 20px;
            background: rgba(0,0,0,0.7); padding: 10px; border-radius: 10px;
            font-size: 12px; min-width: 150px;
        }
        
        .leaderboard-mini {
            position: absolute; top: 280px; right: 20px;
            background: rgba(0,0,0,0.7); padding: 10px; border-radius: 10px;
            font-size: 11px; max-width: 200px; max-height: 150px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-overlay">
        <div class="connection-status" id="connectionStatus">
            <span class="connecting">Connecting...</span>
        </div>
        
        <div class="hud">
            <div>Position: <span id="coords">0, 0, 0</span></div>
            <div>Score: <span id="score">0</span></div>
            <div>Discoveries: <span id="discoveries">0</span></div>
            <div>Rare Items: <span id="rare">0</span></div>
            <div>Creatures Found: <span id="creatures">0</span></div>
            <div>Players Online: <span id="playerCount">1</span></div>
            <div style="color: #ff6b6b;">Radiation: <span id="radiation">0</span>%</div>
            <div id="speed-indicator" style="color: #4ecdc4; display: none;">+0% Speed</div>
        </div>
        
        <div class="speed-boost-indicator" id="speedBoostIndicator">
            <div class="speed-boost-timer" id="speedBoostTimer">3.5x SPEED</div>
            <div class="speed-boost-text">Collection Boost!</div>
            <div class="speed-boost-text" id="speedBoostCountdown">2.0s</div>
        </div>
        
        <div class="player-list" id="playerList">
            <div style="font-weight: bold; margin-bottom: 5px;">Other Players</div>
            <div style="opacity: 0.7; font-size: 11px;">No other players nearby</div>
        </div>
        
        <div class="pvp-stats" id="pvpStats">
            <div style="font-weight: bold; margin-bottom: 5px; color: #ff6b6b;">üè¥‚Äç‚ò†Ô∏è PvP Stats</div>
            <div>Stolen: <span id="resourcesStolen">0</span></div>
            <div>Lost: <span id="resourcesLost">0</span></div>
            <div>Deaths: <span id="deathCount">0</span></div>
            <div>Kills: <span id="killCount">0</span></div>
        </div>
        
        <div class="leaderboard-mini" id="leaderboardMini">
            <div style="font-weight: bold; margin-bottom: 5px; color: #ffd700;">üëë Top Players</div>
            <div>Loading...</div>
        </div>
        
        <div class="controls">
            <div>WASD - Move | QE - Up/Down | Arrow Keys - Look | Shift - Boost</div>
            <div>Enter - Chat | R - Reset | M - Music | V - Voice</div>
        </div>
        
        <div class="chat-container">
            <div class="chat-messages" id="chatMessages"></div>
            <input type="text" class="chat-input" id="chatInput" placeholder="Press Enter to chat..." maxlength="100">
        </div>
        
        <div class="radar" id="radar">
            <div style="position: absolute; top: -20px; left: 50%; transform: translateX(-50%); font-size: 10px;">Players</div>
        </div>
        
        <div class="notification" id="notification">
            <div id="notifText">Welcome!</div>
        </div>
        
        <div class="proximity-countdown" id="proximityCountdown">
            <div class="proximity-timer" id="proximityTimer">6</div>
            <div class="proximity-text">PROXIMITY BATTLE</div>
            <div class="proximity-text" id="proximityTarget">vs Enemy Player</div>
            <div class="proximity-text" id="proximityDistance">Distance: 25m</div>
            <div style="font-size: 0.9em; margin-top: 10px; color: #ffaaaa;">Higher radiation dies!</div>
        </div>
        
        <div class="player-indicators" id="playerIndicators"></div>
        
        <div class="radiation-overlay" id="radiationOverlay"></div>
        <div class="glitch-overlay" id="glitchOverlay"></div>
    </div>
    
    <div class="death-screen" id="deathScreen">
        <h1 class="death-title">‚ò†Ô∏è ELIMINATED ‚ò†Ô∏è</h1>
        <div class="respawn-countdown" id="respawnCountdown">Respawning in 5 seconds...</div>
        <div style="text-align: center; margin: 20px 0;">
            <div id="deathCause">Radiation Overload</div>
            <div>Deaths: <span id="finalDeathCount">1</span> | Kills: <span id="finalKillCount">0</span></div>
        </div>
    </div>
    
    <div class="start-screen" id="startScreen">
        <h1 class="game-title">Ethereal Exploration</h1>
        <h2 style="color: #4ecdc4; margin-bottom: 20px;">Enhanced PvP Edition</h2>
        <p style="text-align: center; max-width: 600px; margin: 20px;">
            Compete in intense multiplayer battles! Collect resources faster than others, steal from competitors,
            and survive proximity battles where the most irradiated player dies!
            Speed boosts, radiation management, and tactical positioning are key to victory.
        </p>
        <button class="start-button" onclick="startGame()">Enter Battle</button>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        console.log('üéÆ Starting Enhanced Ethereal Exploration PvP');
        
        // Global variables
        let scene, camera, renderer;
        let player = { x: 0, y: 0, z: 0, rotationX: 0, rotationY: 0 };
        let keys = {};
        let objects = [];
        let discoveries = 0;
        let rareItems = 0;
        let creaturesFound = 0;
        let score = 0;
        let gameStarted = false;
        let socket;
        let playerId;
        let playerName;
        let chatFocused = false;
        let audioContext, masterGain;
        let musicPlaying = false;
        let ambientOscillators = [];
        
        // üé§ Text-to-Speech for chat
        let speechSynthesis = window.speechSynthesis;
        let availableVoices = [];
        let chatTTSEnabled = true;
        
        // ‚ö° ENHANCED PVP SYSTEM VARIABLES
        let baseSpeed = 1.0;
        let currentSpeedMultiplier = 1.0;
        let speedBoostEndTime = 0;
        let speedBoostDuration = 2000;
        let proximityBattles = new Map();
        let proximityWarningSound = null;
        let isInProximityBattle = false;
        let proximityBattleStartTime = 0;
        let proximityTarget = null;
        
        // Enhanced player state
        let isAlive = true;
        let deathCount = 0;
        let killCount = 0;
        let resourcesStolen = 0;
        let resourcesLost = 0;
        let lastDeathTime = 0;
        let respawnTime = 5000;
        
        // Radiation system
        let radiationLevel = 0;
        let maxRadiation = 100;
        let radiationRate = 0; // Server controlled now
        let lastJumpscareTime = 0;
        
        // Server settings (received from server)
        let PVP_SETTINGS = {
            baseSpeed: 1.0,
            boostSpeed: 3.5,
            boostDuration: 2000,
            scoreSpeedBonus: 0.005,
            maxScoreSpeed: 2.5,
        };
        
        let WORLD_SETTINGS = {
            proximityKillDistance: 50,
            proximityKillTime: 6000,
            stealRadius: 100
        };
        
        // Multiplayer
        let otherPlayers = new Map();
        let playerDots = [];
        
        let gameStartTime = 0;
        let survivalTime = 0;
        
        function startGame() {
            console.log('üöÄ Starting enhanced PvP game...');
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('deathScreen').style.display = 'none';
            gameStarted = true;
            gameStartTime = Date.now();
            
            // Reset game state
            player = { x: 0, y: 0, z: 0, rotationX: 0, rotationY: 0 };
            discoveries = 0;
            rareItems = 0;
            creaturesFound = 0;
            score = 0;
            radiationLevel = 0;
            survivalTime = 0;
            isAlive = true;
            
            // Clear objects
            objects.forEach(obj => scene.remove(obj));
            objects = [];
            
            // Reset camera
            camera.position.set(0, 0, 0);
            camera.rotation.set(0, 0, 0);
            
            // Generate local world and start systems
            generateWorld();
            startMusic();
            initSocket();
        }
        
        function initSocket() {
            console.log('üîå Connecting to enhanced server...');
            document.getElementById('connectionStatus').innerHTML = '<span class="connecting">Connecting...</span>';
            
            socket = io();
            
            socket.on('connect', () => {
                console.log('‚úÖ Connected to enhanced server:', socket.id);
                document.getElementById('connectionStatus').innerHTML = '<span class="connected">Connected</span>';
                showNotification('Connected to enhanced PvP server!');
                addChatMessage('System', 'Connected! Enhanced PvP mode active - proximity battles enabled!');
            });
            
            socket.on('disconnect', () => {
                console.log('‚ùå Disconnected from server');
                document.getElementById('connectionStatus').innerHTML = '<span class="disconnected">Disconnected</span>';
                addChatMessage('System', 'Disconnected from server');
            });
            
            socket.on('player_init', (data) => {
                console.log('üë§ Player initialized with PvP settings:', data);
                playerId = data.id;
                playerName = data.name;
                player.x = data.x;
                player.y = data.y;
                player.z = data.z;
                camera.position.set(player.x, player.y, player.z);
                
                // Apply server settings
                if (data.pvpSettings) {
                    PVP_SETTINGS = { ...PVP_SETTINGS, ...data.pvpSettings };
                    console.log('‚ö° PvP settings received:', PVP_SETTINGS);
                }
                if (data.worldSettings) {
                    WORLD_SETTINGS = { ...WORLD_SETTINGS, ...data.worldSettings };
                    console.log('üåç World settings received:', WORLD_SETTINGS);
                }
                
                addChatMessage('System', `You are ${playerName} - enhanced PvP mode active!`);
                
                // Start sending position updates
                setInterval(() => {
                    if (socket && socket.connected && gameStarted && isAlive) {
                        socket.emit('player_update', {
                            x: player.x,
                            y: player.y,
                            z: player.z,
                            rotationX: player.rotationX,
                            rotationY: player.rotationY,
                            radiationLevel: radiationLevel
                        });
                    }
                }, 100); // More frequent updates for PvP
            });
            
            socket.on('game_state', (data) => {
                if (!data) return;
                
                console.log('üéÆ Enhanced game state received:', {
                    players: data.players?.length,
                    totalPlayers: data.totalPlayers
                });
                
                if (data.players) {
                    updateOtherPlayers(data.players);
                    updatePlayerList(data.players);
                    updatePlayerDots(data.players);
                    checkProximityBattles(data.players);
                }
                
                if (data.totalPlayers) updatePlayerCount(data.totalPlayers);
                
                // Update enhanced player stats
                if (data.yourStats) {
                    updatePlayerStats(data.yourStats);
                }
            });
            
            // üéØ NEW: Handle speed boost notifications
            socket.on('speed_boost_granted', (data) => {
                console.log('‚ö° Speed boost granted:', data);
                showSpeedBoost(data.multiplier, data.duration);
                showNotification(`‚ö° Speed Boost! ${data.multiplier}x for ${data.duration/1000}s`, 2000);
            });
            
            socket.on('speed_boost_ended', (data) => {
                console.log('‚ö° Speed boost ended, new multiplier:', data.newMultiplier);
                hideSpeedBoost();
                currentSpeedMultiplier = data.newMultiplier;
                updateSpeedDisplay();
            });
            
            // üéØ NEW: Handle proximity battles
            socket.on('proximity_battle_start', (data) => {
                console.log('‚öîÔ∏è Proximity battle started:', data);
                startProximityBattle(data);
            });
            
            socket.on('proximity_battle_end', (data) => {
                console.log('‚öîÔ∏è Proximity battle ended:', data);
                endProximityBattle(data);
            });
            
            socket.on('proximity_kill', (data) => {
                console.log('üíÄ Proximity kill occurred:', data);
                showNotification(`üíÄ ${data.victimName} eliminated in proximity battle!`, 4000);
                addChatMessage('System', `‚öîÔ∏è ${data.victimName} died in proximity battle (radiation: ${data.radiationLevel}%)`);
            });
            
            // üéØ NEW: Handle player death/respawn
            socket.on('player_death', (data) => {
                console.log('üíÄ Player death:', data);
                if (data.playerId === playerId) {
                    handleOwnDeath(data);
                } else {
                    showNotification(`üíÄ ${data.playerName} eliminated!`, 3000);
                    addChatMessage('System', `üíÄ ${data.playerName} was eliminated (${data.cause})`);
                }
            });
            
            socket.on('player_respawn', (data) => {
                console.log('üîÑ Player respawned:', data);
                if (data.playerId === playerId) {
                    handleOwnRespawn(data);
                } else {
                    showNotification(`üîÑ ${data.playerName} respawned!`, 2000);
                    addChatMessage('System', `üîÑ ${data.playerName} is back in the fight!`);
                }
            });
            
            socket.on('respawn_complete', (data) => {
                console.log('‚úÖ Respawn complete:', data);
                player.x = data.x;
                player.y = data.y;
                player.z = data.z;
                radiationLevel = data.radiationLevel;
                camera.position.set(player.x, player.y, player.z);
                isAlive = true;
                document.getElementById('deathScreen').style.display = 'none';
                document.getElementById('connectionStatus').classList.remove('dead');
                showNotification('‚úÖ Respawned! Back in the fight!', 3000);
            });
            
            // Handle enhanced collection results
            socket.on('collection_result', (data) => {
                console.log('üéØ Enhanced collection result:', data);
                
                if (!data.success && data.reason === 'stolen') {
                    playSound(150);
                    showNotification(`üò§ ${data.stolenBy} stole your resource! (${data.thiefDistance}m vs ${data.yourDistance}m)`, 5000);
                    addChatMessage('System', `üè¥‚Äç‚ò†Ô∏è ${data.stolenBy} stole a resource from you!`);
                    score = Math.max(0, score - 10);
                } else if (data.success) {
                    if (data.speedBoost) {
                        currentSpeedMultiplier = PVP_SETTINGS.boostSpeed;
                        speedBoostEndTime = Date.now() + PVP_SETTINGS.boostDuration;
                        showSpeedBoost(PVP_SETTINGS.boostSpeed, PVP_SETTINGS.boostDuration);
                    }
                    if (data.competitorCount > 0) {
                        showNotification(`üí™ Beat ${data.competitorCount} competitors! +${data.points} points`, 3000);
                    }
                }
            });
            
            socket.on('radiation_warning', (data) => {
                console.log('‚ò¢Ô∏è Radiation warning:', data);
                showNotification(`‚ò¢Ô∏è ${data.message}`, 3000);
                playRadiationWarningSound();
            });
            
            // Handle enhanced resource events
            socket.on('resource_stolen', (data) => {
                console.log('üè¥‚Äç‚ò†Ô∏è Resource stolen:', data);
                if (data.thief !== playerName && data.victim !== playerName) {
                    showNotification(`üè¥‚Äç‚ò†Ô∏è ${data.thief} stole from ${data.victim}!`, 3000);
                }
                addChatMessage('System', `üè¥‚Äç‚ò†Ô∏è ${data.thief} stole ${data.objectType} from ${data.victim}! (+${data.points} pts)${data.speedBoost ? ' ‚ö°' : ''}`);
            });
            
            socket.on('resource_collected', (data) => {
                console.log('‚úÖ Resource collected:', data);
                if (data.collector !== playerName) {
                    const competitorText = data.competitorCount > 0 ? ` (beat ${data.competitorCount} competitors)` : '';
                    const boostText = data.speedBoost ? ' ‚ö°' : '';
                    addChatMessage('System', `${data.collector} found ${data.objectType}! (+${data.points} pts)${competitorText}${boostText}`);
                }
            });
            
            socket.on('object_removed', (data) => {
                console.log('üóëÔ∏è Object removed:', data);
                
                // Remove from local objects immediately
                const objIndex = objects.findIndex(obj => obj.userData.serverId === data.objectId);
                if (objIndex > -1) {
                    const obj = objects[objIndex];
                    scene.remove(obj);
                    objects.splice(objIndex, 1);
                    console.log(`‚úÖ Removed object ${data.objectId} collected by ${data.collectedBy}`);
                }
                
                // Show collection notification if it was us
                if (data.collectorId === playerId && data.points) {
                    score += data.points;
                    updateLocalStats();
                    showNotification(`‚úÖ +${data.points} points! ${data.speedBoost ? '‚ö° Speed boost!' : ''}`, 2000);
                }
            });
            
            socket.on('leaderboard_update', (data) => {
                console.log('üèÜ Enhanced leaderboard update:', data);
                updateLeaderboard(data.leaderboard, data.battleStats);
            });
            
            socket.on('chat_message', (data) => {
                console.log('üí¨ Enhanced chat message:', data);
                addChatMessage(data.playerName, data.message);
                
                if (chatTTSEnabled && data.playerId !== playerId) {
                    speakChatMessage(data.playerName, data.message);
                }
                
                if (data.playerId !== playerId) {
                    showNotification(`üí¨ ${data.playerName}: ${data.message}`, 3000);
                }
            });
            
            socket.on('player_joined', (data) => {
                console.log('üëã Player joined:', data);
                addChatMessage('System', `${data.name} joined the battle!`);
                updatePlayerCount(data.totalPlayers);
            });
            
            socket.on('player_left', (data) => {
                console.log('üëã Player left:', data);
                addChatMessage('System', `${data.name} left (Score: ${data.finalScore}, Deaths: ${data.deaths}, Kills: ${data.kills})`);
                updatePlayerCount(data.totalPlayers);
            });
        }
        
        function updatePlayerStats(stats) {
            console.log('üìä Updating enhanced player stats:', stats);
            
            // Update core stats
            score = stats.score;
            discoveries = stats.discoveries;
            rareItems = stats.rareItems;
            creaturesFound = stats.creatures;
            radiationLevel = stats.radiationLevel;
            currentSpeedMultiplier = stats.currentSpeedMultiplier || 1.0;
            speedBoostEndTime = stats.speedBoostEndTime || 0;
            isAlive = stats.isAlive;
            deathCount = stats.deathCount || 0;
            killCount = stats.killCount || 0;
            resourcesStolen = stats.resourcesStolen || 0;
            resourcesLost = stats.resourcesLost || 0;
            
            updateLocalStats();
            updateSpeedDisplay();
            updatePvPStats();
        }
        
        function updateLocalStats() {
            document.getElementById('score').textContent = score;
            document.getElementById('discoveries').textContent = discoveries;
            document.getElementById('rare').textContent = rareItems;
            document.getElementById('creatures').textContent = creaturesFound;
            document.getElementById('radiation').textContent = Math.round(radiationLevel);
            
            // Update radiation color and effects
            const radiationElement = document.getElementById('radiation');
            if (radiationLevel < 30) {
                radiationElement.style.color = '#4ecdc4';
                radiationElement.style.textShadow = 'none';
            } else if (radiationLevel < 60) {
                radiationElement.style.color = '#ffd93d';
                radiationElement.style.textShadow = 'none';
            } else if (radiationLevel < 85) {
                radiationElement.style.color = '#ff6b6b';
                radiationElement.style.textShadow = 'none';
            } else {
                radiationElement.style.color = '#ff0000';
                radiationElement.style.textShadow = '0 0 10px #ff0000';
            }
            
            updateRadiationEffects();
        }
        
        function updateSpeedDisplay() {
            const speedIndicator = document.getElementById('speed-indicator');
            if (speedIndicator) {
                const speedPercent = Math.round((currentSpeedMultiplier - 1) * 100);
                if (speedPercent > 0) {
                    speedIndicator.textContent = `+${speedPercent}% Speed`;
                    speedIndicator.style.display = 'block';
                    
                    // Color based on speed type
                    if (currentSpeedMultiplier >= PVP_SETTINGS.boostSpeed) {
                        speedIndicator.style.color = '#00ff00'; // Bright green for boost
                    } else {
                        speedIndicator.style.color = '#4ecdc4'; // Normal speed bonus color
                    }
                } else {
                    speedIndicator.style.display = 'none';
                }
            }
        }
        
        function updatePvPStats() {
            document.getElementById('resourcesStolen').textContent = resourcesStolen;
            document.getElementById('resourcesLost').textContent = resourcesLost;
            document.getElementById('deathCount').textContent = deathCount;
            document.getElementById('killCount').textContent = killCount;
        }
        
        function showSpeedBoost(multiplier, duration) {
            const indicator = document.getElementById('speedBoostIndicator');
            const timer = document.getElementById('speedBoostTimer');
            const countdown = document.getElementById('speedBoostCountdown');
            
            timer.textContent = `${multiplier}x SPEED`;
            indicator.style.display = 'block';
            
            const startTime = Date.now();
            const updateCountdown = () => {
                const remaining = Math.max(0, duration - (Date.now() - startTime));
                countdown.textContent = `${(remaining / 1000).toFixed(1)}s`;
                
                if (remaining > 0) {
                    requestAnimationFrame(updateCountdown);
                } else {
                    hideSpeedBoost();
                }
            };
            updateCountdown();
        }
        
        function hideSpeedBoost() {
            document.getElementById('speedBoostIndicator').style.display = 'none';
        }
        
        function startProximityBattle(data) {
            isInProximityBattle = true;
            proximityBattleStartTime = Date.now();
            proximityTarget = data.players.find(p => p.id !== playerId);
            
            const countdown = document.getElementById('proximityCountdown');
            const timer = document.getElementById('proximityTimer');
            const target = document.getElementById('proximityTarget');
            const distance = document.getElementById('proximityDistance');
            
            countdown.style.display = 'block';
            
            if (proximityTarget) {
                target.textContent = `vs ${proximityTarget.name}`;
                distance.textContent = `Radiation: You ${Math.round(radiationLevel)}% vs ${Math.round(proximityTarget.radiationLevel)}%`;
            }
            
            // Start countdown
            const updateTimer = () => {
                const elapsed = Date.now() - proximityBattleStartTime;
                const remaining = Math.max(0, data.timeLimit - elapsed);
                
                timer.textContent = Math.ceil(remaining / 1000);
                
                if (remaining > 0 && isInProximityBattle) {
                    requestAnimationFrame(updateTimer);
                }
            };
            updateTimer();
            
            playProximityWarningSound();
            showNotification(`‚öîÔ∏è PROXIMITY BATTLE! ${data.timeLimit/1000}s timer started!`, 3000);
        }
        
        function endProximityBattle(data) {
            isInProximityBattle = false;
            proximityTarget = null;
            document.getElementById('proximityCountdown').style.display = 'none';
            
            if (proximityWarningSound) {
                proximityWarningSound.stop();
                proximityWarningSound = null;
            }
        }
        
        function checkProximityBattles(players) {
            if (!players || players.length === 0) return;
            
            let inDanger = false;
            let closestEnemy = null;
            let minDistance = Infinity;
            
            players.forEach(otherPlayer => {
                const distance = Math.sqrt(
                    Math.pow(otherPlayer.x - player.x, 2) +
                    Math.pow(otherPlayer.y - player.y, 2) +
                    Math.pow(otherPlayer.z - player.z, 2)
                );
                
                if (distance <= WORLD_SETTINGS.proximityKillDistance && distance < minDistance) {
                    inDanger = true;
                    closestEnemy = otherPlayer;
                    minDistance = distance;
                }
            });
            
            // Send proximity danger update to server
            if (socket && socket.connected) {
                socket.emit('proximity_danger_update', {
                    inDanger: inDanger,
                    targetPlayer: closestEnemy ? closestEnemy.name : null,
                    distance: inDanger ? Math.round(minDistance) : null
                });
            }
        }
        
        function handleOwnDeath(data) {
            isAlive = false;
            deathCount = data.deathCount;
            
            document.getElementById('deathScreen').style.display = 'flex';
            document.getElementById('connectionStatus').classList.add('dead');
            document.getElementById('deathCause').textContent = 
                data.cause === 'radiation' ? 'Radiation Overload' : 
                data.cause === 'proximity' ? 'Proximity Battle' : 'Eliminated';
            document.getElementById('finalDeathCount').textContent = data.deathCount;
            document.getElementById('finalKillCount').textContent = killCount;
            
            // Start respawn countdown
            let remainingTime = data.respawnTime / 1000;
            const updateCountdown = () => {
                document.getElementById('respawnCountdown').textContent = 
                    `Respawning in ${Math.ceil(remainingTime)} seconds...`;
                remainingTime -= 0.1;
                
                if (remainingTime > 0) {
                    setTimeout(updateCountdown, 100);
                }
            };
            updateCountdown();
            
            playDeathSound();
            showNotification('üíÄ You have been eliminated!', 5000);
        }
        
        function handleOwnRespawn(data) {
            // Server will send respawn_complete event with new position
        }
        
        function updateOtherPlayers(players) {
            console.log('üë• Updating other players:', players.length, 'players received');
            
            if (!players || players.length === 0) {
                console.log('‚ùå No players data received');
                return;
            }
            
            // Remove old players that are no longer in the list
            for (const [id, playerObj] of otherPlayers) {
                if (!players.find(p => p.id === id)) {
                    console.log(`‚ûñ Removing player ${playerObj.data.name} from scene`);
                    scene.remove(playerObj.mesh);
                    otherPlayers.delete(id);
                }
            }
            
            // Add/update players
            players.forEach(playerData => {
                let playerObj = otherPlayers.get(playerData.id);
                
                if (!playerObj) {
                    console.log(`üé® Creating 3D mesh for ${playerData.name} at distance ${playerData.distance}m`);
                    
                    const group = new THREE.Group();
                    
                    // Main body
                    const bodyGeometry = new THREE.CylinderGeometry(3, 3, 12, 8);
                    const bodyMaterial = new THREE.MeshLambertMaterial({
                        color: playerData.color,
                        emissive: new THREE.Color(playerData.color).multiplyScalar(0.4)
                    });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    group.add(body);
                    
                    // Head
                    const headGeometry = new THREE.SphereGeometry(2.5, 8, 6);
                    const headMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color(playerData.color).multiplyScalar(1.2),
                        emissive: new THREE.Color(playerData.color).multiplyScalar(0.3)
                    });
                    const head = new THREE.Mesh(headGeometry, headMaterial);
                    head.position.y = 8;
                    group.add(head);
                    
                    // Enhanced glowing indicator based on player state
                    const glowGeometry = new THREE.SphereGeometry(4, 8, 6);
                    const glowColor = playerData.isAlive ? playerData.color : 0xff0000;
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: glowColor,
                        emissive: new THREE.Color(glowColor).multiplyScalar(0.8)
                    });
                    const glowSphere = new THREE.Mesh(glowGeometry, glowMaterial);
                    glowSphere.position.y = 15;
                    group.add(glowSphere);
                    
                    // Enhanced name label with stats
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 256;
                    canvas.height = 64;
                    context.fillStyle = playerData.isAlive ? '#ffffff' : '#ff6b6b';
                    context.font = '20px Arial';
                    context.textAlign = 'center';
                    
                    const statusText = playerData.isAlive ? 
                        `${playerData.name} (${playerData.score})` : 
                        `${playerData.name} üíÄ`;
                    context.fillText(statusText, 128, 30);
                    
                    // Speed indicator
                    if (playerData.currentSpeedMultiplier > 1.2) {
                        context.fillStyle = '#00ff00';
                        context.font = '16px Arial';
                        context.fillText('‚ö°', 128, 50);
                    }
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const labelMaterial = new THREE.SpriteMaterial({ map: texture });
                    const label = new THREE.Sprite(labelMaterial);
                    label.position.y = 25;
                    label.scale.set(20, 5, 1);
                    group.add(label);
                    
                    group.position.set(playerData.x, playerData.y, playerData.z);
                    scene.add(group);
                    
                    playerObj = { mesh: group, data: playerData };
                    otherPlayers.set(playerData.id, playerObj);
                    
                    const statusMsg = playerData.isAlive ? `appeared` : `is eliminated`;
                    showNotification(`üëã ${playerData.name} ${statusMsg} at ${playerData.distance}m!`, 4000);
                } else {
                    // Update existing player position and status
                    console.log(`üîÑ Moving ${playerData.name} to (${Math.round(playerData.x)}, ${Math.round(playerData.y)}, ${Math.round(playerData.z)}) - ${playerData.distance}m away`);
                    playerObj.mesh.position.set(playerData.x, playerData.y, playerData.z);
                    
                    // Update glow color based on status
                    if (playerObj.mesh.children[2]) { // glow sphere
                        const glowColor = playerData.isAlive ? playerData.color : 0xff0000;
                        playerObj.mesh.children[2].material.color.setHex(glowColor);
                        playerObj.mesh.children[2].material.emissive.setHex(glowColor).multiplyScalar(0.8);
                    }
                    
                    playerObj.data = playerData;
                }
            });
            
            console.log(`üë• Scene now has ${otherPlayers.size} other players visible`);
        }
        
        function updatePlayerDots(players) {
            console.log('üì° Updating radar with players:', players);
            playerDots
